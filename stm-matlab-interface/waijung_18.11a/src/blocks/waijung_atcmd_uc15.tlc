%implements waijung_atcmd_uc15 "C"
%selectfile NULL_FILE

%function addParametersToBlock(block) void
  %assign conf = CAST("String",SFcnParamSettings.conf)
  %assign sampletime = CAST("Number",SFcnParamSettings.sampletime)
  %assign blockid = block.Identifier

	%assign targetname = optionstring[0]
	%assign uart_port = optionstring[1]
	%assign apn = optionstring[2]
	%assign user = optionstring[3]
	%assign password = optionstring[4]
	%assign syncinterval = optionstring[5]
	%assign pwrkey_port = optionstring[6]
	%assign pwrkey_pin = optionstring[7]
	%assign reset_port = optionstring[8]
	%assign reset_pin = optionstring[9]
    %assign vbatenable_port = optionstring[10]
    %assign vbatenable_pin = optionstring[11]
	%assign port_a_used = optionstring[12]
	%assign port_b_used = optionstring[13]
	%assign port_c_used = optionstring[14]
	%assign port_d_used = optionstring[15]
	%assign port_e_used = optionstring[16]
	%assign port_f_used = optionstring[17]
	%assign port_g_used = optionstring[18]
	%assign port_h_used = optionstring[19]
	%assign port_i_used = optionstring[20]
    %assign target_upgrade = optionstring[21]

  %% Size of optionstring: %<SIZE(optionstring)[1]>
  %assign block = block + conf + sampletime + blockid \
     + targetname + uart_port + apn + user + password \
     + syncinterval + pwrkey_port + pwrkey_pin + reset_port \
     + reset_pin + vbatenable_port + vbatenable_pin \
     + port_a_used + port_b_used + port_c_used \
     + port_d_used + port_e_used + port_f_used + port_g_used \
     + port_h_used + port_i_used + target_upgrade
%endfunction

%function BlockTypeSetup(block, system) void
%<addParametersToBlock(block)>
   %if (EXISTS(::__STRING_LIB_H__) == 0)
      %assign :: __STRING_LIB_H__ = 1
      %openfile tmpBuf
         #include <string.h>
      %closefile tmpBuf
      %assign file = LibCreateSourceFile("Header", "Custom", "waijung_hwdrvlib")
      %<LibAddSourceFileCustomSection(file,"Declarations","cIncludes")>
      %<LibSetSourceFileCustomSection(file,"cIncludes",tmpBuf)>
   %endif
   %if (EXISTS(::__STDIO_LIB_H__) == 0)
      %assign :: __STDIO_LIB_H__ = 1
      %openfile tmpBuf
         #include <stdlib.h>
      %closefile tmpBuf
      %assign file = LibCreateSourceFile("Header", "Custom", "waijung_hwdrvlib")
      %<LibAddSourceFileCustomSection(file,"Declarations","cIncludes")>
      %<LibSetSourceFileCustomSection(file,"cIncludes",tmpBuf)>
   %endif
   %if (EXISTS(::__STDIO_IO_H__) == 0)
      %assign :: __STDIO_IO_H__ = 1
      %openfile tmpBuf
         #include <stdio.h>
      %closefile tmpBuf
      %assign file = LibCreateSourceFile("Header", "Custom", "waijung_hwdrvlib")
      %<LibAddSourceFileCustomSection(file,"Declarations","cIncludes")>
      %<LibSetSourceFileCustomSection(file,"cIncludes",tmpBuf)>
   %endif

   %openfile tmpBuf
     /* ########################################################################
      * Name: %<Name>
      * Id: %<blockid>
      * ########################################################################
      */
	#define UC15_PROC_BUFFER_SIZE 	(2048)
    #define APP_PROC_URL_SIZE (1024)
    #define APP_PROC_DATA_SIZE (2048)

    typedef struct
    {
	    uint32_t output;
	    uint8_t date[3]; // dd,mo,yy
	    uint8_t time[3]; // hh,mm,ss
	    uint32_t date_value;
	    uint32_t time_value;
	    uint8_t selector [32];
	    float lux;
    	float soil[6];
	    float humid;
	    float temp;
	    float rsvd1;
        float rsvd2;
    	float mcutemp;
    	uint32_t fw;
    	float waterlevel;
        uint32_t magnetic;
        uint32_t debug1;
        uint32_t debug2;
        uint32_t debug3;
        uint32_t debug4;
        uint32_t debug5;

        //char wireless_sensor[128];
        float wb[5];
        float wh[5];
        float wt[5];
        float ws[5];

    	char isotime[32];
    } AMG_POST_DATA_STRUCT;
    extern AMG_POST_DATA_STRUCT aMG_Post_Data_Struct;

    uint8_t uc15_session_lock (uint8_t *session);

    typedef struct
    {
        uint32_t Power_Key_Reset;
        uint32_t Power_Main_Reset;
        uint8_t Requst_Sync_Setting;
        uint8_t Active_Server_Idx;
    } UC15_MODULE_PWRCMD;

    extern UC15_MODULE_PWRCMD UC15_Module_Pwrcmd;

    int16_t UC15_GetSystem_Message (char *msg, int16_t output_len);
    int16_t UC15_SetSystemMessage (const char *msg);

	// HTTP Method processing status
	typedef enum
	{
		STA_HTTP_IDLE = 0,
		STA_HTTP_BUSY,
		STA_HTTP_DATA,
		STA_HTTP_SUCCESS,
		STA_HTTP_ERROR,
		STA_HTTP_TIMEOUT,
	} STA_HTTP_STATUS;

    char * string_follow_with (const char *str, const char *start);

    void _uc15_get_datatime (uint8_t *datetime_7);
    void _uc15_set_datatime (uint8_t *datetime_7);
    STA_HTTP_STATUS aMG_Upload_Data (uint8_t *session, uint8_t uploading_type, uint32_t channel, const char *str);
    STA_HTTP_STATUS aMG_Download_Setting (uint8_t *session, uint8_t channel, char *output, int32_t output_len, uint16_t *return_len);
    STA_HTTP_STATUS aMG_Download_Setting_Version (uint8_t *session, uint32_t *version);
    STA_HTTP_STATUS aMG_Download_Firmware (uint8_t *session, const char *target, 
        uint32_t flash_sta, uint32_t signature, uint32_t flash_data_count, uint32_t *flash_cmd,
        uint32_t *flash_offset, uint32_t *flash_data);
    STA_HTTP_STATUS aMG_Http_Get (uint8_t *session, const char *url, int32_t url_len, 
        char *output, int32_t output_len, uint16_t *return_len);
    STA_HTTP_STATUS aMG_Http_Post (uint8_t *session, const char *action, 
        int32_t action_len, const char *body, int32_t body_len);
    STA_HTTP_STATUS aMG_Sms_Send (uint8_t *session, 
        const char *number, uint8_t max_count, int32_t number_len, const char *body, int32_t body_len, uint8_t *err_code, uint8_t *succ_cnt, uint8_t *err_cnt);
    STA_HTTP_STATUS aMG_Email_Send (uint8_t *session, 
       const char *server, int32_t server_len, 
       uint32_t port,
       const char *user, int32_t user_len,
       const char *pass, int32_t pass_len,
       const char *sender, int32_t sender_len,
       const char *to, int32_t to_len,
       const char *cc, int32_t cc_len,
       const char *subject, int32_t subject_len,
       const char *body, int32_t body_len);
    STA_HTTP_STATUS aMG_Get_System_Conf (uint8_t *session, uint32_t *antid, char *remoteid, uint16_t remoteid_len);
    STA_HTTP_STATUS aMG_Get_NetworkTime (uint8_t *session, uint8_t *datetime_7);

   %closefile tmpBuf
   %assign file = LibCreateSourceFile("Header", "Custom", "waijung_hwdrvlib")
   %<LibAddSourceFileCustomSection(file,"Declarations","cFunctions")>
   %<LibSetSourceFileCustomSection(file,"cFunctions",tmpBuf)>

   %openfile tmpBuf


   %closefile tmpBuf
   %assign file = LibCreateSourceFile("Source", "Custom", "waijung_hwdrvlib")
   %<LibAddSourceFileCustomSection(file,"Declarations","cFunctions")>
   %<LibSetSourceFileCustomSection(file,"cFunctions",tmpBuf)>

%endfunction

%function BlockInstanceSetup(block, system) void
%<addParametersToBlock(block)>

%openfile tmpBuf
/* ########################################################################
 * Name: %<Name>
 * Id: %<blockid>
 * ########################################################################
*/
%if conf == "upload_data"
uint8_t %<blockid>_Upload_Data(uint8_t trig, const uint8_t *data, uint16_t data_len);
%endif

%if conf == "upload_setting"
uint8_t %<blockid>_Upload_Setting(uint8_t trig, const char *data, uint16_t data_len);
%endif

%if conf == "upload_setting_version"
uint8_t %<blockid>_Upload_Setting_Version(uint8_t trig, const uint32_t *version);
%endif

%if conf == "upload_sysmsg"
uint8_t %<blockid>_Upload_SystemMessage(uint8_t trig, const uint8_t *data, uint16_t data_len);
%endif

%if conf == "download_setting"
uint8_t %<blockid>_Download_Setting(uint8_t trig, uint8_t channel, uint8_t *output, uint16_t output_len, uint16_t *return_len);
%endif

%if conf == "download_setting_version"
uint8_t %<blockid>_Download_Setting_Version(uint8_t trig, uint32_t *version);
%endif

%if conf == "download_firmware"
uint8_t %<blockid>_Download_Firmware (uint8_t trig, uint32_t flash_sta,
      uint32_t signature, uint32_t *flash_cmd, uint32_t *flash_offset,
      uint32_t *flash_data, uint32_t flash_data_count);
%endif

%if conf == "get"
uint8_t %<blockid>_HTTP_GET(uint8_t trig, const uint8_t *url, int32_t url_len, 
     uint8_t *output, uint16_t output_len, uint16_t *return_len);
%endif

%if conf == "post"
uint8_t %<blockid>_HTTP_POST(uint8_t trig, const uint8_t *action, int32_t action_len, 
      const uint8_t *body, uint16_t body_len);
%endif

%if conf == "sms"
uint8_t %<blockid>_SMS_Send(uint8_t trig, uint8_t max_count, const uint8_t *number, int32_t number_len, 
      const uint8_t *body, uint16_t body_len, uint8_t *err_code, uint8_t *scc_cnt, uint8_t *err_cnt);
%endif

%% --- email ---
%if conf == "email"
uint8_t %<blockid>_EMAIL_Send(uint8_t trig, 
       const uint8_t *server, int32_t server_len, 
       uint32_t port,
       const uint8_t *user, int32_t user_len,
       const uint8_t *pass, int32_t pass_len,
       const uint8_t *sender, int32_t sender_len,
       const uint8_t *to, int32_t to_len,
       const uint8_t *cc, int32_t cc_len,
       const uint8_t *subject, int32_t subject_len,
       const uint8_t *body, int32_t body_len);
%endif

%% --- systemconf ---
%if conf == "systemconf"
uint8_t %<blockid>_System_Conf (uint8_t trig, uint32_t *antid, uint8_t *remoteid, uint16_t remoteid_len);
%endif

%% --- getnetworktime ---
%if conf == "getnetworktime"
uint8_t  %<blockid>_Get_NetworkTime (uint8_t trig, uint8_t *datetime_7);
%endif

%% --- getrssi ---
%if conf == "getrssi"
int32_t %<blockid>_get_rssi(void);
%endif

void enable_%<blockid>(void);
%closefile tmpBuf
%assign file = LibCreateSourceFile("Header", "Custom", "waijung_hwdrvlib")
%<LibAddSourceFileCustomSection(file,"Declarations","cFunctions")>
%<LibSetSourceFileCustomSection(file,"cFunctions",tmpBuf)>

%openfile tmpBuf
/* ########################################################################
 * Name: %<Name>
 * Id: %<blockid> 
 * ########################################################################
*/
%if conf == "setup"
     typedef enum
     {
	   UC15_OK = 0,
	   UC15_BUSY,
	   UC15_TIMEOUT,
	   UC15_RETRY,
	   UC15_ERROR
     } UC15_STATUS;

	// Module info
	static struct
	{
		int32_t signal_quality;
        uint32_t ant_id;
		uint8_t module_info[64];
		uint8_t ip_address[4];
		uint8_t imei [32];
        uint8_t datetime[7]; // [yy|mo|dd|hh|mm|ss|tz]
	} UC15_Module_Info;

    int32_t _uc15_get_rssi (void)
    {
        return UC15_Module_Info.signal_quality;
    }

    void _uc15_get_module_info(char *buffer_64)
    {
        strcpy (buffer_64, UC15_Module_Info.module_info);
    }

    void _uc15_get_datatime (uint8_t *datetime_7)
    {
        memcpy(datetime_7,UC15_Module_Info.datetime, 7);
    }

    void _uc15_set_datatime (uint8_t *datetime_7)
    {
        if ((datetime_7[0] < 50) && (datetime_7[0] >= 17)) {
        memcpy(UC15_Module_Info.datetime, datetime_7, 7);
        }
    }

	// Configuration
	static struct
	{
		char Apn [32];
		char User[32];
		char Pass[32];
		uint8_t ssl_enable;
	} UC15_Module_Setting;

    // POWER Command
    UC15_MODULE_PWRCMD UC15_Module_Pwrcmd = {0,0,0,0};

	// Session control
	#define MAX_SESSION 255
	static uint8_t uc15_active_session = 1; // Current active of session
	static uint8_t uc15_running_session = 0; // Running number of aquiring session

	// Packet communication
	const char read_packet_term [] = "\r\n";
	static UARTRX_BUFFER_READ_STRUCT uc15_read_struct = {0,0,0};

	// Internal buffer processing
	static char uc15_proc_buffer [UC15_PROC_BUFFER_SIZE];

    static char app_proc_url [APP_PROC_URL_SIZE];

    char app_proc_data [APP_PROC_DATA_SIZE];

    #define APP_SYSTEM_MESSAGE (512)
    static char UC15_System_Message[APP_SYSTEM_MESSAGE];;

	// Retry count
	#define ATCMD_RETRY_MAXCOUNT 8

	// Control Pin
	#define UC15_PWRKEY_PIN_NUMBER %<pwrkey_pin>
	#define UC15_RESET_PIN_NUMBER  %<reset_pin>
    #define UC15_VBATENABLE_PIN_NUMBER %<vbatenable_pin>

	#define UC15_RESETKEY_LOW() {nrf_gpio_pin_write (UC15_RESET_PIN_NUMBER, 1);}
	#define UC15_RESETKEY_HIGH() {nrf_gpio_pin_write (UC15_RESET_PIN_NUMBER, 0);}
	#define UC15_PWRKEY_LOW() {nrf_gpio_pin_write (UC15_PWRKEY_PIN_NUMBER,1);}
	#define UC15_PWRKEY_HIGH() {nrf_gpio_pin_write (UC15_PWRKEY_PIN_NUMBER,0);}
    #define UC15_VBAT_ENABLE() {nrf_gpio_pin_write (UC15_VBATENABLE_PIN_NUMBER,1);}
    #define UC15_VBAT_DISABLE() {nrf_gpio_pin_write (UC15_VBATENABLE_PIN_NUMBER,0);}

char * string_follow_with (const char *str, const char *start)
{
	char *p;
	
	if (!str || !start)
		return 0;
	
	p = strstr(str,start);
	if (p)
		p+= strlen(start);
	return p;
}	

	// Session value, non zero: 1-255
	uint8_t uc15_session_run (void)
	{
		uc15_running_session ++;
		if (uc15_running_session == 0)
			uc15_running_session = 1;
		return uc15_running_session;
	}

	void uc15_session_init(uint8_t *session)
	{
		// Initial value 
		*session = 0;
	}

	// 0 - No lock, 1 - Locked
	uint8_t uc15_session_lock (uint8_t *session)
	{
		// Assign session id
		if (*session == 0) {
			*session = uc15_session_run(); // Increment running session
		}
		
		// Check session id
		if (*session == uc15_active_session)
			return 1;
		else
			return 0;
	}

	uint8_t uc15_session_release (uint8_t *session)
	{
		if (*session == uc15_active_session)
		{
			uc15_active_session ++;
			if (uc15_active_session == 0)
				uc15_active_session	= 1;
			*session = 0;
			return 1; // Success
		}
		else
		{
			return 0; // Fail
		}
	}

	void uc15_uart_flush (void)
	{
		uint8_t buffer[8];
		uint16_t reading_count = 0;
		do {
			UART0_ReadEx(&uc15_read_struct, buffer, (uint16_t)sizeof(buffer), &reading_count);
		} while (reading_count > 0);
	}

	void uc15_uart_write(const char *s)
	{
		UART0_Write((const uint8_t *)s, (uint16_t)strlen(s));
	}

	void uc15_uart_writeln(const char *s)
	{
		// Flush previous data may left on the buffer
		uc15_uart_flush();
		// Transmit data with packet line terminator
		UART0_Write((const uint8_t *)s, (uint16_t)strlen(s));
		UART0_Write((const uint8_t *)"\r", 1); // Packet terminator 
	}

	// Return:
	// 	len - length of receiving data
	uint16_t uc15_uart_readln (char *buffer, uint16_t buffer_size)
	{
		uint16_t len;
		
		// Read line
	  len = UART0_ReadLine(&uc15_read_struct, read_packet_term, strlen(read_packet_term), (uint8_t *)buffer, buffer_size);
		return len;
	}

    // Return: UC15_OK, UC15_BUSY, UC15_TIMEOUT
	UC15_STATUS uc15_atcmd_configure (uint8_t init, const char * cmd, const char * expect_return, uint32_t timeout_ms)
	{
		uint16_t len;
		static SYS_TIMER_STRUCT time_ms = {0, 0};
			
		if (init)
		{
			uc15_uart_writeln (cmd);
			SysTimer_Start(&time_ms, timeout_ms);
		}
		else
		{
			UART0_Temp_Buffer[0] = '\0';
			len = uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE);
			if (len && strstr((char *)UART0_Temp_Buffer, (char *)expect_return))
			{
				return UC15_OK;
			}
			else
			{
				if (SysTimer_IsTimeout(&time_ms))
					return UC15_TIMEOUT;
			}
		}
		return UC15_BUSY;
	}

    // Return: UC15_OK, UC15_BUSY, UC15_TIMEOUT
	UC15_STATUS uc15_atcmd_query (uint8_t init, const char *query, const char *ret_begin, uint32_t timeout_ms, char *buffer, uint16_t buffer_size)
	{
		uint16_t len;
		static SYS_TIMER_STRUCT time_ms = {0, 0};
			
		if (init)
		{
		    if (strlen(query) > 0) {
			    uc15_uart_writeln (query);
		    }
			SysTimer_Start(&time_ms, timeout_ms);
		}
		else
		{
			UART0_Temp_Buffer[0] = '\0';
			len = uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE);
			
			if (len && !strcmp(ret_begin,"*") && strncmp((char *)UART0_Temp_Buffer,query,strlen(query)) &&(UART0_Temp_Buffer[0] != 0x0D) && (UART0_Temp_Buffer[0] != 0x0A))
			{
				char *s;
				if (len >= buffer_size)
					len = (buffer_size-1);
				memcpy(buffer, (char *)UART0_Temp_Buffer, len);
				buffer[len] = '\0';
				
				s = strstr(buffer, read_packet_term);
				if (s)
					*s = '\0';
				
				return UC15_OK;			
			}
			else  if (len && (!strncmp((char *)UART0_Temp_Buffer, ret_begin, strlen(ret_begin))))
			{
				if (len >= buffer_size)
					len = (buffer_size-1);
				memcpy(buffer, (char *)UART0_Temp_Buffer, len);
				buffer[len] = '\0';
				return UC15_OK;
			}
			else
			{
				if (SysTimer_IsTimeout(&time_ms))
					return UC15_TIMEOUT;
			}		
		}
		return UC15_BUSY;	
	}

    // Return number of bytes getting from system message buffer
    int16_t UC15_GetSystem_Message (char *msg, int16_t output_len)
    {
        int32_t len;

        len = strlen (UC15_System_Message);
        if (len)
        {
            if (len >= output_len)
                len = output_len - 1;
            memcpy (msg, UC15_System_Message, len);
        }
        msg [len] = '\0';

        // Clear
        UC15_System_Message [0] = '\0';
        
        return (int16_t) len;
    }

    // Return number of bytes putting to buffer
    int16_t UC15_SetSystemMessage (const char *msg)
    {
        char *s;
        int32_t input_len, valid_len;

        input_len = strlen (msg);
        valid_len = APP_SYSTEM_MESSAGE - strlen (UC15_System_Message);
        
        if (valid_len >= input_len)
        {
            strcpy (&UC15_System_Message[strlen(UC15_System_Message)], msg);
            return input_len;
        }
        else
        {
            return 0;
        }
    }

	typedef enum
	{
		READFILE_STATE_IDLE,
		READFILE_STATE_INIT,
		READFILE_STATE_CLOSE_OPENNING, // Close the previous openning file (if any)
		READFILE_STATE_GETSIZE, // Get file info to determine size
		READFILE_STATE_OPEN,
		READFILE_STATE_SEEKPOST,
		READFILE_STATE_READING,
		READFILE_STATE_READ,
		READFILE_STATE_READEND,
		READFILE_STATE_CLOSING,
		READFILE_STATE_CLOSED,
		READFILE_STATE_TIMEOUT,
		READFILE_STATE_ERROR,
		READFILE_STATE_SUCCESS
	} READFILE_STATE;

	static uint32_t uc15_file_handle = 0;

	UC15_STATUS uc15_atcmd_readfile (uint8_t init, const char *filename, 
		uint32_t seekpos, uint32_t readsize, uint8_t *output, 
        uint32_t *reading_size, uint32_t *file_size)
	{
		static SYS_TIMER_STRUCT timer_ms = {0, 0};	
		static READFILE_STATE read_state = READFILE_STATE_IDLE; // Assume current state start with idle
		static READFILE_STATE read_state_last = READFILE_STATE_INIT; // Assume last state was init
		static UC15_STATUS ret = UC15_BUSY;
		
		static uint8_t err_active = 0;
		static uint8_t timeout_active = 0;
		
		static uint32_t total_size = 0;
		static uint32_t packet_size =0;
		static uint32_t reading_index = 0;

        static uint32_t total_file_size = 0;
		
		uint8_t on_enter;
		
		// Check for initial flag
		if (init)
		{
			ret = UC15_BUSY;
			
			// Init operation state
			read_state = READFILE_STATE_INIT;
			read_state_last = READFILE_STATE_IDLE;
		}
		
		// Determine on enter state
		if (read_state != read_state_last)
		{
			on_enter = 1;
			read_state_last = read_state; // Update last operation state
		}
		else
		{
			on_enter = 0;
		}
		
		// Operating state
		switch (read_state)
		{
			case READFILE_STATE_IDLE:
				// Do nothing, return the previous status
				break;
			
			case READFILE_STATE_INIT:
				// Reset error/ timeout flag
				err_active = 0;
				timeout_active = 0;
                total_file_size = 0;
			
				if (uc15_file_handle)
					read_state = READFILE_STATE_CLOSE_OPENNING;
				else
					read_state = READFILE_STATE_GETSIZE;
				break;
			
			case READFILE_STATE_CLOSE_OPENNING:
				if (on_enter)
				{
					sprintf((char *)UART0_Temp_Buffer,"AT+QFCLOSE=%u", uc15_file_handle);
					uc15_uart_writeln((char *)UART0_Temp_Buffer);
					SysTimer_Start(&timer_ms, 2000);
				}
				else
				{
					if (uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE))
					{
						if (!strncmp((char *)UART0_Temp_Buffer,"OK", 2) 
							|| !strncmp((char *)UART0_Temp_Buffer,"+CME ERROR", 10))
							read_state = READFILE_STATE_GETSIZE;
					}
					else
					{
						// Timeout check
						// Ignore if timeout
						if (SysTimer_IsTimeout(&timer_ms))
							read_state = READFILE_STATE_GETSIZE;
					}
				}
				break;
			
			case READFILE_STATE_GETSIZE:
				if (on_enter)
				{
					sprintf((char *)UART0_Temp_Buffer,"AT+QFLST=\"RAM:%s\"", filename);
					uc15_uart_writeln((char *)UART0_Temp_Buffer);
					SysTimer_Start(&timer_ms, 2000);	
					
					// Initial total size, reading index
					total_size = 0;
					reading_index = 0;
				}
				else
				{
					if (uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE))
					{
						if (!strncmp((char *)UART0_Temp_Buffer, "+QFLST:", 7))
						{
							char *s = strstr((char *)UART0_Temp_Buffer, ",");
							if (s) s++;
							if (!sscanf(s,"%u",&total_size))
								total_size = 0; // sscanf failed

                            // Update file size
                            total_file_size = total_size;
						}
						else if (!strncmp((char *)UART0_Temp_Buffer, "OK", 2))
						{
							if ((total_size > 0) && (total_size > seekpos))
							{
								// Success, file size received
								// seekpos compensate
								total_size = total_size - seekpos;
								// Re-adjust size
								if (total_size > readsize)
									total_size = readsize;
								// Open file
								read_state = READFILE_STATE_OPEN;
							}
							else
							{
								//Error: not receive file size or invalid seekpos
								read_state = READFILE_STATE_ERROR;
							}
						}
						else if (!strncmp((char *)UART0_Temp_Buffer, "+CME ERROR:", 11))
						{
				        read_state = READFILE_STATE_ERROR;
						}					
						//else: Un-expected, ignore
					}
					else
					{
						// Timeout check
						if (SysTimer_IsTimeout(&timer_ms))
							read_state = READFILE_STATE_TIMEOUT;
					}
				}
				break;
			
			case READFILE_STATE_OPEN:
				if (on_enter)
				{
					sprintf((char *)UART0_Temp_Buffer,"AT+QFOPEN=\"RAM:%s\",2", filename);
					uc15_uart_writeln((char *)UART0_Temp_Buffer);
					SysTimer_Start(&timer_ms, 2000);				
				}
				else
				{
					if (uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE))
					{
						if (!strncmp((char *)UART0_Temp_Buffer, "+QFOPEN:", 8))
						{
							char *s = (char *)UART0_Temp_Buffer;
							if (sscanf(s,"+QFOPEN: %u",&uc15_file_handle) && (uc15_file_handle > 0))
							{
								// Wait to receive "OK"
							}
							else // Error
								read_state = READFILE_STATE_ERROR;
						}
						else if (!strncmp((char *)UART0_Temp_Buffer, "OK", 2))
						{
							if (uc15_file_handle > 0)
								read_state = READFILE_STATE_SEEKPOST;
						}
						else if (!strncmp((char *)UART0_Temp_Buffer, "+CME ERROR:", 11))
						{
				            read_state = READFILE_STATE_ERROR;
						}
						//else: Un-expected, ignore
					}
					else
					{
						// Timeout check
						if (SysTimer_IsTimeout(&timer_ms))
							read_state = READFILE_STATE_TIMEOUT;
					}
				}
				break;
			
			case READFILE_STATE_SEEKPOST:
				if (on_enter)
				{
					if (seekpos > 0)
					{
						sprintf((char *)UART0_Temp_Buffer,"AT+QFSEEK=%u,%u", uc15_file_handle, seekpos);
						uc15_uart_writeln((char *)UART0_Temp_Buffer);
						SysTimer_Start(&timer_ms, 2000);
					}
					else
					{
						// Skip Seek command
						read_state = READFILE_STATE_READING;
					}
				}
				else
				{
					if (uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE))
					{
						if (!strncmp((char *)UART0_Temp_Buffer, "OK", 2))
						{
							read_state = READFILE_STATE_READING;
						}
						else if (!strncmp((char *)UART0_Temp_Buffer, "+CME ERROR:", 11))
						{
				            read_state = READFILE_STATE_ERROR;
						}					
					}
					else
					{
						// Timeout check
						if (SysTimer_IsTimeout(&timer_ms))
							read_state = READFILE_STATE_TIMEOUT;				
					}
				}
				break;
			
			case READFILE_STATE_READING:
				if (on_enter)
				{
					// Determine reading packet size
					if (reading_index < total_size)
					{
						packet_size = (URX0_BUFFER_SIZE >> 1);
						if (packet_size > 256)
							packet_size = 256; // Limit number of bytes
						
						if ((total_size - reading_index) < packet_size)
							packet_size = (total_size - reading_index);
						
						//AT+QFREAD=<handle>,<size>
						sprintf((char *)UART0_Temp_Buffer,"AT+QFREAD=%u,%u", uc15_file_handle, packet_size);
						uc15_uart_writeln((char *)UART0_Temp_Buffer);
						
						SysTimer_Start(&timer_ms, 2000);					
					}
					else
					{
						// All bytes ready
						// Update output
						*reading_size = total_size;
						
						// Success
						read_state = READFILE_STATE_SUCCESS;
					}
				}
				else
				{
					if (uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE))
					{
						if (!strncmp((char *)UART0_Temp_Buffer, "CONNECT", 7))
						{
							// Adjust read size
							if (sscanf((char *)UART0_Temp_Buffer,"CONNECT %u", &packet_size) && packet_size)
								read_state = READFILE_STATE_READ;
						}
					}
					else
					{
						// Timeout check
						if (SysTimer_IsTimeout(&timer_ms))
							read_state = READFILE_STATE_TIMEOUT;				
					}				
				}
				break;
			
			case READFILE_STATE_READ:
				if (on_enter)
				{
					SysTimer_Start(&timer_ms, 2000);	
				}
				else
				{
					uint16_t reading_count = 0;
					UART0_ReadEx(&uc15_read_struct, UART0_Temp_Buffer, packet_size,&reading_count);
					if (packet_size == reading_count)
					{
						memcpy(&output[reading_index], UART0_Temp_Buffer, packet_size);
						reading_index += packet_size;
						
						// Wait for "OK" of ERROR
						read_state = READFILE_STATE_READEND;
					}
					else
					{
						// Check timeout
						if (SysTimer_IsTimeout(&timer_ms))
						{
							read_state = READFILE_STATE_TIMEOUT;
						}
						
						// Restore bytes
						if (reading_count > 0)
							UART0_RestoreBytes(&uc15_read_struct, reading_count);
					}			
				}
				break;
			
			case READFILE_STATE_READEND:
				if (on_enter) {
					SysTimer_Start(&timer_ms, 1000);	
				}
				else {
					if (uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE))
					{
						if (!strncmp((char *)UART0_Temp_Buffer, "OK", 2))
							read_state = READFILE_STATE_READING;
						else if (!strncmp((char *)UART0_Temp_Buffer, "+CME ERROR:", 11))
				read_state = READFILE_STATE_ERROR;
					}
					else
					{
						// Timeout check
						if (SysTimer_IsTimeout(&timer_ms))
							read_state = READFILE_STATE_TIMEOUT;				
					}
				}
				break;
			
			case READFILE_STATE_CLOSING:
				if (on_enter)
				{
					sprintf((char *)UART0_Temp_Buffer,"AT+QFCLOSE=%u", uc15_file_handle);
					uc15_uart_writeln((char *)UART0_Temp_Buffer);
					SysTimer_Start(&timer_ms, 2000);
				}
				else
				{
					if (uc15_uart_readln ((char *)UART0_Temp_Buffer, URX0_BUFFER_SIZE))
					{
						if (!strncmp((char *)UART0_Temp_Buffer,"OK", 2))
							{
								uc15_file_handle =0;
								read_state = READFILE_STATE_CLOSED;
							}
					}
					else
					{
						// Timeout check
						// Ignore if timeout
						if (SysTimer_IsTimeout(&timer_ms))
							read_state = READFILE_STATE_CLOSED;
					}
				}
				break;
			
			case READFILE_STATE_CLOSED:
				if (timeout_active)
					read_state = READFILE_STATE_TIMEOUT;
				else if (err_active)
					read_state = READFILE_STATE_ERROR;
				else
					read_state = READFILE_STATE_SUCCESS;
				break;
			
			case READFILE_STATE_TIMEOUT:
				timeout_active = 1;
				if (uc15_file_handle)
					read_state = READFILE_STATE_CLOSING;
				else
					ret = UC15_TIMEOUT;
				break;
			
			case READFILE_STATE_ERROR:
				err_active = 1;
				if (uc15_file_handle)
					read_state = READFILE_STATE_CLOSING;
				else
					ret = UC15_ERROR;
				break;
			
			case READFILE_STATE_SUCCESS:
				if (uc15_file_handle)
				{
					read_state = READFILE_STATE_CLOSING;
				}
				else
				{
					ret = UC15_OK;
					*reading_size = total_size;
                    *file_size = total_file_size;
				}
				break;
			
			default:
				break;
		}
		
		return ret;
	}

	UC15_STATUS uc15_atcmd_readtextfile (uint8_t init, const char *filename, 
		uint32_t seekpos, uint32_t readsize, char *output)
	{
		// Append null terminate for this mode
		UC15_STATUS ret;
		uint32_t reading_size, file_size;
		
		ret = uc15_atcmd_readfile (init, filename, seekpos, (readsize-1), (uint8_t *)output, &reading_size, &file_size);
		if (ret == UC15_OK)
		{
			// string terminate
			output[reading_size] = '\0';
		}
		return ret;
	}

	typedef enum
	{
        MODULE_CONNECT_INIT = 0,

        MODULE_VBAT_RESET,
        MODULE_VBAT_RESET_WAIT,
        MODULE_PWRKEY_RESET,
        MODULE_PWRKEY_RESET_WAIT,

		MODULE_CONNECT_TEST,
		MODULE_CONNECT_RESET_KEY,
		MODULE_CONNECT_PWRDWN_KEY,
		MODULE_CONNECT_HWFLOW_CNTRL,
		MODULE_CONNECT_NETWORK_REGISTERAION,
		
		MODULE_CONNECT_SIGNAL_QUALITY,
		MODULE_CONNECT_IMEI,
        
        MODULE_CONNECT_INFO,
        MODULE_FIRMWARE_INFO,

		MODULE_CONNECT_NETWORK_TIME,

		MODULE_CONNECT_NETWORK_WAIT,
		MODULE_CONNECT_NETWORK_SUCCESS,
        MODULE_CONNECT_NETWORK_ERROR,
		MODULE_CONNECT_PWRDWN_UNKNOWN=255
	} MODULE_CONNECT_STATE;

	UC15_STATUS uc15_module_connect (uint8_t init)
	{
		static MODULE_CONNECT_STATE connect_state = MODULE_CONNECT_TEST;
		static MODULE_CONNECT_STATE connect_state_last = MODULE_CONNECT_PWRDWN_UNKNOWN;
		static uint8_t retry_count = 0;
		static uint8_t pwrkey_retry_count = 0;
		static UC15_STATUS ret = UC15_BUSY;
		static SYS_TIMER_STRUCT timer_ms = {0, 0};
		static SYS_TIMER_STRUCT poll_reset_timer_ms = {0, 0};

		static uint8_t sub_state = 0;
		
		uint8_t on_enter;
		UC15_STATUS sta = UC15_BUSY;
		
		// Detect init state
		if (init)
		{
			// Init state
			connect_state = MODULE_CONNECT_INIT;
			connect_state_last = MODULE_CONNECT_PWRDWN_UNKNOWN;
			// Reset retry count
			retry_count = 0;
			pwrkey_retry_count = 0;
			// Status Busy
			ret = UC15_BUSY;
		}
		
		if (connect_state != connect_state_last)
		{
			on_enter = 1; // Activate on enter state event
			connect_state_last = connect_state; // Update last state
		}
		else
		{
			on_enter = 0;
		}
		
		// --- State Operation ---
		switch (connect_state)
		{
            case MODULE_CONNECT_INIT:
                if ((UC15_Module_Pwrcmd.Power_Main_Reset == 0xAABBCCDD)
                    || (SysTimer_IsTimeout(&poll_reset_timer_ms)))
                {
                    SysTimer_Start (&poll_reset_timer_ms, 3600000); // 60 Minutes

                    UC15_Module_Pwrcmd.Power_Main_Reset = 0;
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0;
                    connect_state = MODULE_VBAT_RESET;
                }
                else if (UC15_Module_Pwrcmd.Power_Key_Reset == 0xEEFFAABB) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0;
                    connect_state = MODULE_PWRKEY_RESET;
                }
                else {
                    connect_state = MODULE_CONNECT_TEST;
                }
                break;

            case MODULE_VBAT_RESET:
                if (on_enter)
                {
                    UC15_RESETKEY_HIGH();
                    UC15_PWRKEY_HIGH();

                    UC15_VBAT_DISABLE();
                    //SysTimer_Start (&timer_ms, 5000);
                    SysTimer_Start (&timer_ms, 1000);
                }
                if (SysTimer_IsTimeout(&timer_ms))
                    connect_state = MODULE_VBAT_RESET_WAIT;
                break;

            case MODULE_VBAT_RESET_WAIT:
                if (on_enter)
                {
                    UC15_VBAT_ENABLE();
                    //SysTimer_Start (&timer_ms, 5000);                
                    SysTimer_Start (&timer_ms, 1000);                
                }
                if (SysTimer_IsTimeout(&timer_ms))
                    connect_state = MODULE_PWRKEY_RESET;
                break;

            case MODULE_PWRKEY_RESET:
                if (on_enter)
                {
                    UC15_PWRKEY_LOW();
                    //SysTimer_Start (&timer_ms, 2000); 
                    SysTimer_Start (&timer_ms, 1000); 
                }
                if (SysTimer_IsTimeout(&timer_ms))
                    connect_state = MODULE_PWRKEY_RESET_WAIT;
                break;

            case MODULE_PWRKEY_RESET_WAIT:
                if (on_enter)
                {
                    UC15_PWRKEY_HIGH();
                    //SysTimer_Start (&timer_ms, 10000);
                    SysTimer_Start (&timer_ms, 5000);
                }
                if (SysTimer_IsTimeout(&timer_ms))
                {
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 1;
                    connect_state = MODULE_CONNECT_TEST;
                }
                break;

			case MODULE_CONNECT_TEST: // Transmit "AT\r" Commad
				if (on_enter)
				{
					retry_count	= 0;
				}
				
				if (pwrkey_retry_count > 1)
				{
					ret = UC15_TIMEOUT;
				}
				else
				{
					sta = uc15_atcmd_configure (on_enter, "AT", "OK", 1000);
					if (sta == UC15_OK) {
						// Return OK status
						connect_state = MODULE_CONNECT_HWFLOW_CNTRL;
					}
					else if (sta == UC15_TIMEOUT)
					{
						if (++ retry_count < ATCMD_RETRY_MAXCOUNT)
						{
							// Retry operation
							uc15_atcmd_configure (1 /*Init*/, "AT", "OK", 1000);
						}
						else
						{
							// 3G Module did not response
							// Activate Reset Key
							connect_state = MODULE_CONNECT_RESET_KEY;
						}
					} // else - unexpected
				}
				break;
				
			case MODULE_CONNECT_RESET_KEY:
				if (on_enter)
				{
					SysTimer_Start(&timer_ms, 100);
					sub_state = 0;
					
					// PWRKEY HIGH
					UC15_PWRKEY_HIGH();			
					
					// Set RESET pin Low
					UC15_RESETKEY_LOW();
				}
				
				if (sub_state == 0)
				{
					if (SysTimer_IsTimeout(&timer_ms))
					{
						SysTimer_Start(&timer_ms, 2000);
						sub_state ++;
					}
				}
				else
				{
					// Set RESET pin to High
					UC15_RESETKEY_HIGH();
					if (SysTimer_IsTimeout(&timer_ms))
					{
						// To activate PWRKEY
						connect_state = MODULE_CONNECT_PWRDWN_KEY;
					}
				}
				break;
			
			case MODULE_CONNECT_PWRDWN_KEY:
				if (on_enter)
				{
					SysTimer_Start(&timer_ms, 2000);
					sub_state = 0;
					
					// Set RESET pin Low
					UC15_PWRKEY_LOW()
				}
				
				if (sub_state == 0)
				{
					if (SysTimer_IsTimeout(&timer_ms))
					{
						SysTimer_Start(&timer_ms, 10000);
						sub_state ++;
					}
				}
				else
				{
					// Set RESET pin to High
					UC15_PWRKEY_HIGH();
					if (SysTimer_IsTimeout(&timer_ms))
					{
						// Retry test command
						pwrkey_retry_count ++;
						// Back to Test command
						connect_state = MODULE_CONNECT_TEST;
					}
				}
				break;
				
			case MODULE_CONNECT_HWFLOW_CNTRL:
				if (on_enter)
				{
					retry_count	= 0;
				}
				
				if (UART0_HW_FLOW)
				{
					// AT+IFC=2,2
					sta = uc15_atcmd_configure (on_enter, "AT+IFC=2,2", "OK", 1000);
				}
				else
				{
					// AT+IFC=0,0
					sta = uc15_atcmd_configure (on_enter, "AT+IFC=0,0", "OK", 1000);				
				}
				
				if (sta == UC15_OK) {
					connect_state = MODULE_CONNECT_NETWORK_REGISTERAION;
				}
				else if (sta == UC15_TIMEOUT)
				{
					if (++retry_count < 3)
					{
						if (UART0_HW_FLOW)
							sta = uc15_atcmd_configure (on_enter, "AT+IFC=2,2", "OK", 2000);
						else
							sta = uc15_atcmd_configure (on_enter, "AT+IFC=0,0", "OK", 2000);				
					}
					else
					{
						connect_state = MODULE_CONNECT_TEST;
					}
				}
				else
				{
					// BUSY, Wait for operation to complete or timeout
				}
				break;
				
			// Network registration
			case MODULE_CONNECT_NETWORK_REGISTERAION:
				if (on_enter)
				{
					retry_count	= 0;
				}
				sta = uc15_atcmd_query (on_enter, "AT+CREG?", "+CREG:", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK)
				{
					int32_t a,b;
					if (sscanf(uc15_proc_buffer, "+CREG: %d,%d", &a, &b) == 2)
					{
						if (b == 1) // 1: Network resigtered
							connect_state = MODULE_CONNECT_SIGNAL_QUALITY; //MODULE_CONNECT_NETWORK_SUCCESS;
						else
							connect_state = MODULE_CONNECT_NETWORK_WAIT;
					}
					else
					{
						if (++retry_count < 5)
							sta = uc15_atcmd_query (1, "AT+CREG?", "+CREG:", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
						else
							connect_state = MODULE_CONNECT_TEST;
					}
				}
				else if (sta == UC15_TIMEOUT)
				{
					if (++retry_count < 5)
						sta = uc15_atcmd_query (1, "AT+CREG?", "+CREG:", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
					else
						connect_state = MODULE_CONNECT_TEST;
				}
				break;
				
			case MODULE_CONNECT_NETWORK_WAIT:
				if (on_enter)
				{
					SysTimer_Start(&timer_ms, 1000);
				}
				
				if (SysTimer_IsTimeout(&timer_ms))
				{
					connect_state = MODULE_CONNECT_NETWORK_REGISTERAION;
				}
				break;
		
			// Signal Quality
			case MODULE_CONNECT_SIGNAL_QUALITY:
				sta = uc15_atcmd_query (on_enter, "AT+CSQ", "+CSQ:", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK)
				{
                    int32_t a=0;
					uint32_t b=0;
					if (sscanf(uc15_proc_buffer,"+CSQ: %d,%u",&a,&b) == 2)
					{
						// Update signal quality
						UC15_Module_Info.signal_quality = a;
					}
				}
				if (sta != UC15_BUSY)
					connect_state = MODULE_CONNECT_IMEI;
				break;
			
			// IMEI		
			case MODULE_CONNECT_IMEI:
				sta = uc15_atcmd_query (on_enter, "AT+GSN", "*", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK)
				{
					// Store
					snprintf((char* )UC15_Module_Info.imei, sizeof(UC15_Module_Info.imei), "IMEI%s", uc15_proc_buffer);
					// Change state
					connect_state = MODULE_CONNECT_INFO ; //MODULE_CONNECT_NETWORK_TIME; //MODULE_CONNECT_NETWORK_SUCCESS;
				}
                else if (sta != UC15_BUSY)
                {
                  connect_state = MODULE_CONNECT_NETWORK_ERROR;
                }
				break;

            case MODULE_CONNECT_INFO:
				sta = uc15_atcmd_query (on_enter, "ATI", "Revision:", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK)
				{
					// Store
                    UC15_Module_Info.module_info[0] = '\0';
                    //snprintf(UC15_Module_Info.module_info, 63, "%s", uc15_proc_buffer);
					// Change state
					connect_state = MODULE_FIRMWARE_INFO; //MODULE_CONNECT_NETWORK_TIME; //MODULE_CONNECT_NETWORK_SUCCESS;
				}
                else if (sta != UC15_BUSY)
                {
                  UC15_Module_Info.module_info[0] = '\0';
                  connect_state = MODULE_FIRMWARE_INFO;
                }
                break;

            case MODULE_FIRMWARE_INFO:
				sta = uc15_atcmd_query (on_enter, "AT+GMR", "*", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK) {
					// Store
                    snprintf(&UC15_Module_Info.module_info[strlen(UC15_Module_Info.module_info)], 48, "Version: %s", uc15_proc_buffer);
					// Change state
					connect_state = MODULE_CONNECT_NETWORK_TIME;
				}
                else if (sta != UC15_BUSY) {
                  connect_state = MODULE_CONNECT_NETWORK_ERROR;
                }
                break;
			
			// Date time
			case MODULE_CONNECT_NETWORK_TIME:
				sta = uc15_atcmd_query (on_enter, "AT+CCLK?", "+CCLK:", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK) {
					// Change state
					connect_state = MODULE_CONNECT_NETWORK_SUCCESS;
				}
                else if (sta != UC15_BUSY) {
                  connect_state = MODULE_CONNECT_NETWORK_ERROR;
                }
               break;
			
			case MODULE_CONNECT_NETWORK_SUCCESS:
				ret = UC15_OK;
				break;		

            case MODULE_CONNECT_NETWORK_ERROR:
	            ret = UC15_ERROR;
                break;
			default:
				ret = UC15_TIMEOUT;
				break;
		}
		return ret;
	}

    typedef enum {
		ACTIVATE_CONTEXT_CONTEXTID = 0,
		ACTIVATE_CONTEXT_RESPONSEHEADER,
		ACTIVATE_CONTEXT_CONTEXT_STATE,
		ACTIVATE_CONTEXT_CONTEXT_CONFIGURE,
		ACTIVATE_CONTEXT_CONTEXT_ACTIVATE,
		// --- SSL ---
		ACTIVATE_CONTEXT_SSLID,
		ACTIVATE_CONTEXT_SSL_VERSION,
		ACTIVATE_CONTEXT_SSL_CIPHERSUITE,
		ACTIVATE_CONTEXT_SSL_SECURELEVEL,
        ACTIVATE_CONTEXT_SSL_IGNORELOCALTIME,     

        ACTIVATE_CONTEXT_UNKONWN,

		ACTIVATE_CONTEXT_SUCCESS,
		ACTIVATE_CONTEXT_TIMEOUT,
		ACTIVATE_CONTEXT_ERROR 
    } ACTIVATE_CONTEXT_STATE;
    UC15_STATUS uc15_activate_context (uint8_t init, uint8_t ssl_enable)
    {
		uint8_t on_enter;
		UC15_STATUS ret;
        UC15_STATUS sta;
		static ACTIVATE_CONTEXT_STATE activate_context_state = ACTIVATE_CONTEXT_RESPONSEHEADER;
		static ACTIVATE_CONTEXT_STATE activate_context_state_last = ACTIVATE_CONTEXT_UNKONWN;

        static uint8_t need_ssl_conf = 0;
        static uint8_t enable_header = 1;
        char tmp_buffer[256];

        if (init){
		  activate_context_state = ACTIVATE_CONTEXT_RESPONSEHEADER;
		  activate_context_state_last = ACTIVATE_CONTEXT_UNKONWN;

          need_ssl_conf = 0;
          enable_header = 0; // Initial as header disable
        }

        if (activate_context_state_last != activate_context_state) {
          activate_context_state_last = activate_context_state;
          on_enter = 1;
        }
        else {
          on_enter = 0;
        }

        ret = UC15_BUSY;
        switch (activate_context_state)
        {
			case ACTIVATE_CONTEXT_CONTEXTID:
				sta = uc15_atcmd_configure (on_enter, "AT+QHTTPCFG=\"contextid\",1", "OK", 2000);
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_CONTEXT_CONFIGURE;
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;
				break;
			
			case ACTIVATE_CONTEXT_RESPONSEHEADER:
				sprintf (uc15_proc_buffer, "AT+QHTTPCFG=\"responseheader\",%u", (uint32_t)enable_header);
				sta = uc15_atcmd_configure (on_enter, uc15_proc_buffer, "OK", 2000);			
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_CONTEXT_STATE;
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;
				break;
			
			case ACTIVATE_CONTEXT_CONTEXT_STATE:
				sta = uc15_atcmd_query (on_enter, "AT+QIACT?", "+QIACT:", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK) {
					int32_t context_id,context_state,context_type,ip1,ip2,ip3,ip4;
					
					if (sscanf(uc15_proc_buffer, "+QIACT: %d,%d,%d,\"%d.%d.%d.%d\"", 
						&context_id, &context_state,&context_type,&ip1,&ip2,&ip3,&ip4) >= 2) {
						if (context_state == 1) {// 1: Activated
							// Store current IP address
							UC15_Module_Info.ip_address [0] = (uint8_t)ip1;
							UC15_Module_Info.ip_address [1] = (uint8_t)ip2;
							UC15_Module_Info.ip_address [2] = (uint8_t)ip3;
							UC15_Module_Info.ip_address [3] = (uint8_t)ip4;
							
							if (need_ssl_conf && ssl_enable)
								activate_context_state = ACTIVATE_CONTEXT_SSLID;
							else
								activate_context_state = ACTIVATE_CONTEXT_SUCCESS;
						}
						else {
							activate_context_state = ACTIVATE_CONTEXT_CONTEXTID;
						}
					}
					else {
						activate_context_state = ACTIVATE_CONTEXT_ERROR;
					}
				}
				else if (sta != UC15_BUSY) { //else if (sta == UC15_TIMEOUT)
					need_ssl_conf = 1;
					activate_context_state = ACTIVATE_CONTEXT_CONTEXTID;
				}
				break;
			
			case ACTIVATE_CONTEXT_CONTEXT_CONFIGURE:
				sprintf((char *)tmp_buffer,"AT+QICSGP=1,1,\"%s\",\"%s\",\"%s\",1", \
					UC15_Module_Setting.Apn, UC15_Module_Setting.User, UC15_Module_Setting.Pass);			

				sta = uc15_atcmd_configure (on_enter, tmp_buffer, "OK", 2000);
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_CONTEXT_ACTIVATE;
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;
				break;
			
			case ACTIVATE_CONTEXT_CONTEXT_ACTIVATE:
				// AT+QIACT=1
				sta = uc15_atcmd_configure (on_enter, "AT+QIACT=1", "OK", 20000); // Timeout 10s
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_CONTEXT_STATE;
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;
				break;
			
			// --- SSL ---
			case ACTIVATE_CONTEXT_SSLID:
				// AT+QHTTPCFG="sslctxid",1
				sta = uc15_atcmd_configure (on_enter, "AT+QHTTPCFG=\"sslctxid\",1", "OK", 2000);
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_SSL_VERSION;
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;
				break;
				
			case ACTIVATE_CONTEXT_SSL_VERSION:
				// AT+QSSLCFG="sslversion",1,1
                sta = uc15_atcmd_configure (on_enter, "AT+QSSLCFG=\"sslversion\",1,3", "OK", 2000); //TLS-1.2
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_SSL_CIPHERSUITE;
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;
				break;
			
			case ACTIVATE_CONTEXT_SSL_CIPHERSUITE:
				sta = uc15_atcmd_configure (on_enter, "AT+QSSLCFG=\"ciphersuite\",1,0xFFFF", "OK", 2000);
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_SSL_SECURELEVEL;
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;
				break;
			
			case ACTIVATE_CONTEXT_SSL_SECURELEVEL:
				sta = uc15_atcmd_configure (on_enter, "AT+QSSLCFG=\"seclevel\",1,0", "OK", 2000);
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_SSL_IGNORELOCALTIME;
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;
				break;

            case ACTIVATE_CONTEXT_SSL_IGNORELOCALTIME:
				sta = uc15_atcmd_configure (on_enter, "AT+QSSLCFG=\"ignorelocaltime\",1,0", "OK", 2000);
				if (sta == UC15_OK)
					activate_context_state = ACTIVATE_CONTEXT_SUCCESS; // All Done
				else if (sta != UC15_BUSY)
					activate_context_state = ACTIVATE_CONTEXT_TIMEOUT;                
                break;

		  	case ACTIVATE_CONTEXT_SUCCESS:
            	ret = UC15_OK;
            	break;

		  	case ACTIVATE_CONTEXT_TIMEOUT:
            	ret = UC15_TIMEOUT;
            	break;

		  	case ACTIVATE_CONTEXT_ERROR:
            default:
            	ret = UC15_ERROR;
            	break;
        }
        return ret;
    }

	// Http operation state
	typedef enum
	{
		APP_HTTP_STATE_CONNECT = 0,
		// --- Http config ---
		APP_HTTP_STATE_CONTEXTID,
		// --- HTTP ---
		APP_HTTP_STATE_URL_INIT,
		APP_HTTP_STATE_URL_SET,
		// --- GET ---
		APP_HTTP_STATE_METHOD_GET,
		// --- POST ---
		APP_HTTP_STATE_METHOD_POST,
		APP_HTTP_STATE_METHOD_POST_BODY,
		// --- Resp ---
		APP_HTTP_STATE_READ,
	//	APP_HTTP_STATE_DOWNLOAD_FILE,
		APP_HTTP_STATE_PROCESSING,
		APP_HTTP_STATE_OUTPUT,
		
		APP_HTTP_STATE_UNKONWN,
		
		APP_HTTP_STATE_SUCCESS,
		APP_HTTP_STATE_TIMEOUT,
		APP_HTTP_STATE_ERROR,
				
		APP_HTTP_STATE_IDLE
	} APP_HTTP_STATE;

	typedef enum
	{
		HTTP_OPERATION_GET = 0,
		HTTP_OPERATION_POST,
		HTTP_OPERATION_DOWNLOAD
	} HTTP_OPERATION;

    static int uc15_http_mothod_result_code = -1;
    int uc15_http_get_http_result_code(void)
    {
        return uc15_http_mothod_result_code;
    }

	// Http GET
	// method 0: GET, 1: POST
	STA_HTTP_STATUS uc15_http_mothod (uint8_t init, HTTP_OPERATION method, uint8_t ssl_enable, 
		const char *url, const char *body, const char *out_begin, const char *out_term, char *out_buffer, uint16_t out_buffer_size)
	{
		static APP_HTTP_STATE http_state = APP_HTTP_STATE_CONNECT;
		static APP_HTTP_STATE http_state_last = APP_HTTP_STATE_UNKONWN;
		static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
		//static SYS_TIMER_STRUCT timer_ms = {0, 0};
		static SYS_TIMER_STRUCT watchdog_timer_ms = {0, 0};

		static uint32_t http_result_code = 0;
		static char redirect_url [512];
		
		static uint8_t need_ssl_conf = 0;
		static uint32_t http_data_len = 0;
		
		static uint8_t enable_header = 1;
		
		char tmp_buffer[256];
		
		uint8_t on_enter;
		UC15_STATUS sta;

		// Detect init state
		if (init)
		{
			// Init state
			http_state = APP_HTTP_STATE_CONNECT;
			http_state_last = APP_HTTP_STATE_UNKONWN;

			// Status Busy
			ret = STA_HTTP_BUSY;
			// Watchdog: Start timer
			SysTimer_Start(&watchdog_timer_ms, 180000);
			//
			need_ssl_conf = 0;
			
			http_data_len = 0;
			
			enable_header = 0; // Initial as header disable
			
			redirect_url[0] = '\0';

            uc15_http_mothod_result_code = -1;
		}
		
		// Check watchdog timer
		if (SysTimer_IsTimeout(&watchdog_timer_ms) && (http_state != APP_HTTP_STATE_IDLE))
		{
			http_state = APP_HTTP_STATE_TIMEOUT;
		}
		
		if (http_state != http_state_last)
		{
			on_enter = 1; // Activate on enter state event
			http_state_last = http_state; // Update last state
		}
		else
		{
			on_enter = 0;
		}	
		
		switch (http_state)
		{
			case APP_HTTP_STATE_IDLE:
				ret = STA_HTTP_IDLE;
				break;
			
			case APP_HTTP_STATE_CONNECT:
				sta = uc15_module_connect (on_enter);
				if (sta == UC15_OK)
					http_state = APP_HTTP_STATE_CONTEXTID;
                else if (sta == UC15_ERROR)
                    http_state = APP_HTTP_STATE_ERROR;
				else if (sta != UC15_BUSY) //else if (sta == UC15_TIMEOUT)
					http_state = APP_HTTP_STATE_TIMEOUT;
				break;
				
			// --- Activate Context ---
			case APP_HTTP_STATE_CONTEXTID:
                sta = uc15_activate_context (on_enter, ssl_enable);
				if (sta == UC15_OK)
					http_state = APP_HTTP_STATE_URL_INIT;
				else if (sta != UC15_BUSY)
					http_state = APP_HTTP_STATE_TIMEOUT;
				break;
			
			// --- HTTP ---
			case APP_HTTP_STATE_URL_INIT:
				if (strlen(redirect_url) > 0)
					sprintf(tmp_buffer, "AT+QHTTPURL=%d,%d", strlen(redirect_url), 80);
				else
					sprintf(tmp_buffer, "AT+QHTTPURL=%d,%d", strlen(url), 80);
				sta = uc15_atcmd_configure (on_enter, tmp_buffer, "CONNECT", 2000);
				if (sta == UC15_OK)
					http_state = APP_HTTP_STATE_URL_SET;
				else if (sta != UC15_BUSY)
					http_state = APP_HTTP_STATE_TIMEOUT;
				break;
			
			case APP_HTTP_STATE_URL_SET:
				if (strlen(redirect_url) > 0)
					sta = uc15_atcmd_configure (on_enter, redirect_url, "OK", 2000);
				else
					sta = uc15_atcmd_configure (on_enter, url, "OK", 2000);
				if (sta == UC15_OK)
				{
					if ((method == HTTP_OPERATION_GET) || (method == HTTP_OPERATION_DOWNLOAD))
						http_state = APP_HTTP_STATE_METHOD_GET; // GET
					else if (method == HTTP_OPERATION_POST)
						http_state = APP_HTTP_STATE_METHOD_POST; // POST
					else
						http_state = APP_HTTP_STATE_ERROR;
				}
				else if (sta != UC15_BUSY)
					http_state = APP_HTTP_STATE_TIMEOUT;			
				break;
				
			// --- GET ---
			case APP_HTTP_STATE_METHOD_GET:
				sta = uc15_atcmd_query (on_enter, "AT+QHTTPGET=80", "+QHTTPGET:", 80000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK)
				{
					int32_t count, err, data_len;
					count = sscanf(uc15_proc_buffer, "+QHTTPGET: %d,%d,%d", &err, &http_result_code, &data_len);
					if ((count >= 2) && (err == 0))
						http_state = APP_HTTP_STATE_READ;
					else
						http_state = APP_HTTP_STATE_ERROR;
				}
				else if (sta != UC15_BUSY)
					http_state = APP_HTTP_STATE_TIMEOUT;
				break;
				
			// --- POST ---
			case APP_HTTP_STATE_METHOD_POST:
				//AT+QHTTPPOST=48,80,80
				sprintf(tmp_buffer, "AT+QHTTPPOST=%d,%d,%d", strlen(body), 80,80);
				sta = uc15_atcmd_configure (on_enter, tmp_buffer, "CONNECT", 30000);
				if (sta == UC15_OK)
					http_state = APP_HTTP_STATE_METHOD_POST_BODY;
				else if (sta != UC15_BUSY)
					http_state = APP_HTTP_STATE_TIMEOUT;			
				break;
				
			case APP_HTTP_STATE_METHOD_POST_BODY:
				// +QHTTPPOST: 0,200,285
				sta = uc15_atcmd_query (on_enter, body, "+QHTTPPOST:", 80000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK)
				{
					int32_t count, err, http_code;
					count = sscanf(uc15_proc_buffer, "+QHTTPPOST: %d,%d", &err, &http_code);
					if ((count == 2) && (err == 0) && ((http_code == 200) || (http_code == 302)))
						http_state = APP_HTTP_STATE_OUTPUT;
					else
						http_state = APP_HTTP_STATE_ERROR;

                    if (count == 2) {
                        if (err != 0)
                            uc15_http_mothod_result_code = err;
                        else
                            uc15_http_mothod_result_code = http_code;
                    }
				}
				else if (sta != UC15_BUSY)
					http_state = APP_HTTP_STATE_TIMEOUT;
				break;
			
			// --- Resp ---
			case APP_HTTP_STATE_READ:
				// AT+QHTTPREADFILE="RAM:tmp.txt",80
				if ((method == HTTP_OPERATION_DOWNLOAD) && (http_result_code == 200))
				{
					sprintf(tmp_buffer, "AT+QHTTPREADFILE=\"RAM:%s\",80", body);
					sta = uc15_atcmd_query (on_enter, tmp_buffer, "+QHTTPREADFILE:", 80000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);				
				}
				else
				{
					sta = uc15_atcmd_query (on_enter, "AT+QHTTPREADFILE=\"RAM:tmp.txt\",80", "+QHTTPREADFILE:", 80000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				}
				if (sta == UC15_OK)
				{
					int32_t count, err;
					count = sscanf(uc15_proc_buffer, "+QHTTPREADFILE: %d", &err);
					if ((count == 1) && (err == 0))
					{
						if ((method == HTTP_OPERATION_DOWNLOAD) && (http_result_code == 200))
							http_state = APP_HTTP_STATE_OUTPUT;
						else
							http_state = APP_HTTP_STATE_PROCESSING;
					}
					else
						http_state = APP_HTTP_STATE_ERROR;
				}
				else if (sta != UC15_BUSY)
					http_state = APP_HTTP_STATE_TIMEOUT;
				break;
			
			case APP_HTTP_STATE_PROCESSING:
				sta = uc15_atcmd_readtextfile (on_enter, "tmp.txt", 0, UC15_PROC_BUFFER_SIZE, uc15_proc_buffer);
				if (sta == UC15_OK)
				{
					http_data_len = strlen(uc15_proc_buffer);
					if (http_data_len > 0)
					{
						// Redirect to another page
						if (http_result_code == 302)
						{
							char *s, *p;
							const char *h1 = "<A HREF=\"";
							const char *h2 = "<a href=\"";
							s = strstr(uc15_proc_buffer, h1);
							if (s)
							{
								s += strlen(h1);
							}
							else
							{
								s = strstr(uc15_proc_buffer, h2);	
								if (s)
									s += strlen(h2);
							}
							if (s && ((p = strstr(s,"\""))!=0) )
							{
								int redirec_url_len = p-s;
								strncpy(redirect_url, s, redirec_url_len);
								redirect_url[redirec_url_len] = '\0';

                                // Re-render url
                                {
	                                char *p, *q;
	                                // &amp;
		                            do {
			                            p = strstr(redirect_url,"&amp;");
			                            if (p) {
				                            q = (p+strlen("&amp;"));
				                            *p++ = '&';
				                            while (*q) {
					                            *p++ = *q++;
				                            }
				                            *p = '\0';
			                            }
		                            } while (p);
                                }

								http_state = APP_HTTP_STATE_URL_INIT;
							}
							else
							{
								http_state = APP_HTTP_STATE_ERROR;
							}
						}
						else if (http_result_code == 200)
						{
							// 200 OK
							// POST or GET
							// const char *out_begin, const char *out_term, char *out_buffer, uint16_t out_buffer_size
							if (out_buffer && out_buffer_size)
							{
								int32_t len;
								char *pbegin, *pterm;
								
								pbegin = 0;
								pterm =0;
								
								// --- Begin ---
								if (out_begin && out_begin[0])
								{
									pbegin = strstr(uc15_proc_buffer, out_begin);
									if (pbegin)
										pbegin += strlen(out_begin);
								}
								if (!pbegin)
									pbegin = (char *) uc15_proc_buffer;
								
								// --- Term ---
								if (out_term && out_term[0])
								{
									pterm = strstr(pbegin,out_term);
									if (pterm)
										*pterm = '\0';
								}
								if (!pterm)
									pterm = &uc15_proc_buffer[http_data_len];
								
								// --- Len ---
								len = pterm - pbegin;
								if (len > (out_buffer_size-1))
									len = (out_buffer_size-1);
								
								// --- Copy ---
								memcpy(out_buffer, pbegin, len);
								out_buffer[len] = '\0';
							}
                            else
                            {
                              out_buffer[0] = '\0';
                            }
							
							http_state = APP_HTTP_STATE_OUTPUT;
						}
                        else
                        {
                            out_buffer[0] = '\0';
                            http_state = APP_HTTP_STATE_ERROR;
                        }
					}
                    else
                    {
                        out_buffer[0] = '\0';
                        http_state = APP_HTTP_STATE_OUTPUT;
                    }
				}
				else if (sta == UC15_ERROR)
					http_state = APP_HTTP_STATE_ERROR;
				else if (sta != UC15_BUSY)
					http_state = APP_HTTP_STATE_TIMEOUT;
				break;
				
			case APP_HTTP_STATE_OUTPUT:
				// DOWNLOAD
				if (method == HTTP_OPERATION_DOWNLOAD)
				{
					
				}
				
				// Success
				http_state = APP_HTTP_STATE_SUCCESS;
				break;

			// --- Success ---
			case APP_HTTP_STATE_SUCCESS:
				ret = STA_HTTP_SUCCESS;
				http_state = APP_HTTP_STATE_IDLE;
				break;
			
			// --- Error ---
			case APP_HTTP_STATE_TIMEOUT:
				ret = STA_HTTP_TIMEOUT;
				http_state = APP_HTTP_STATE_IDLE;
				break;
			
			case APP_HTTP_STATE_ERROR:
				ret = STA_HTTP_ERROR;
				http_state = APP_HTTP_STATE_IDLE;
				break;
			
			default:
				ret = STA_HTTP_ERROR;
                http_state = APP_HTTP_STATE_IDLE;
				break;
		}
		return ret;
	}

    // ********************************************************************
    // Application
    // ********************************************************************
    typedef enum
    {
        MASTER_SETTING_SYNC_IDLE = 0,
        MASTER_SETTING_SYNC_CONNECT, // In case of no IMEI
        MASTER_SETTING_SYNC_DOWNLOAD,
        MASTER_SETTING_SYNC_SUCCESS,
        MASTER_SETTING_SYNC_ERROR
    } MASTER_SETTING_SYNC;

    const char MASTER_SETTING_QUERY[] = "https://doc.google.com/spreadsheets/d/1hjfRfUEjFT7ZMEiOz85j1jIglbDDRAjm9YRqF8Va88g/gviz/tq?tq=select+B,C,D,E+where+A=%"
                                        "%27%s%"
                                        "%27";
    #define MASTER_SETTING_DOWNLOAD_FILENAME   "master.txt"
    STA_HTTP_STATUS aMG_Sync_Master_Setting(void)
    {
        static MASTER_SETTING_SYNC sync_master_setting_state = MASTER_SETTING_SYNC_IDLE;
        static MASTER_SETTING_SYNC sync_master_setting_laststate = MASTER_SETTING_SYNC_IDLE;        
        static SYS_TIMER_STRUCT timer_ms = {0, 0};
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;

        uint8_t on_enter;
        STA_HTTP_STATUS http_sta;
        char tmp_buffer[256];

        if (sync_master_setting_laststate != sync_master_setting_state)
        {
            on_enter = 1;
            sync_master_setting_laststate = sync_master_setting_state;
        }
        else
        {
            on_enter = 0;
        }

        if (!SysTimer_IsTimeout(&timer_ms) && !UC15_Module_Pwrcmd.Requst_Sync_Setting)
        {
            sync_master_setting_state = MASTER_SETTING_SYNC_IDLE;
            // Sync is ready
            ret = STA_HTTP_SUCCESS;
        }
        else
        {
            // Sync required
            switch (sync_master_setting_state)
            {
                case MASTER_SETTING_SYNC_IDLE:
                    ret = STA_HTTP_BUSY;
                    if (UC15_Module_Info.imei[0] == '\0')
                        sync_master_setting_state = MASTER_SETTING_SYNC_CONNECT;
                    else
                        sync_master_setting_state = MASTER_SETTING_SYNC_DOWNLOAD;
                    break;

                case MASTER_SETTING_SYNC_CONNECT:
                    if (uc15_module_connect (on_enter) != UC15_BUSY)
                        sync_master_setting_state = MASTER_SETTING_SYNC_IDLE;
                    break;

                case MASTER_SETTING_SYNC_DOWNLOAD:
                    sprintf(tmp_buffer, MASTER_SETTING_QUERY, (char *)UC15_Module_Info.imei);
                    http_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_DOWNLOAD, 1, tmp_buffer, MASTER_SETTING_DOWNLOAD_FILENAME, "","", 0, 0);
                    if (http_sta == STA_HTTP_SUCCESS)
                        sync_master_setting_state = MASTER_SETTING_SYNC_SUCCESS; // Success
                    else if (http_sta != STA_HTTP_BUSY)
                        sync_master_setting_state = MASTER_SETTING_SYNC_ERROR; // Failed
                    break;

                case MASTER_SETTING_SYNC_SUCCESS:
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 0;
                    // Reset time
                    SysTimer_Start(&timer_ms, %<syncinterval>*1000UL);
                    sync_master_setting_state = MASTER_SETTING_SYNC_IDLE;
                    ret = STA_HTTP_SUCCESS;
                    break;

                case MASTER_SETTING_SYNC_ERROR:
                    sync_master_setting_state = MASTER_SETTING_SYNC_IDLE;
                    ret = STA_HTTP_ERROR;
                    break;
            }
        }

        return ret;
    }

    void aMG_Format_Datetime (float d, float t, char *buffer)
    {
        uint32_t dd,mo,yy,hh,mm,ss;
        char mm_buffer[8];
        char ss_buffer[8];        

        // Decode dd mo yy from data type float
        dd = (uint32_t)(d/10000);
        d -= (dd * 10000);
        mo = (uint32_t)(d/100);
        d -= (mo * 100);
        yy = (uint32_t)d;

        // Decode hh mm ss from data type float
        hh = (uint32_t)(t/10000);
        t -= (hh * 10000);
        mm = (uint32_t)(t/100);
        t -= (mm * 100);
        ss = (uint32_t)t;

        // Minute and Second must be 2 digits
        sprintf (mm_buffer, "%" "2u", mm);
        if (mm_buffer[0] == ' ') mm_buffer[0] = '0';
        sprintf (ss_buffer, "%" "2u", ss);
        if (ss_buffer[0] == ' ') ss_buffer[0] = '0';

        // Format datetime
        sprintf (buffer, "%" "u/" "%" "u/" "%" "u " "%" "u:" "%" "s:" "%" "s", 
                 mo, dd, yy+2000, hh, mm_buffer, ss_buffer);
    }

    void aMG_Format_SelectorSwitch (uint8_t *sel, char *buffer, uint8_t len)
    {
        int i;
        char *s;

        buffer[0] = '|';
        buffer[1] = '\0';
        
        // Selector
        for (i=0; i<len; i++)
        {
            s = &buffer[strlen(buffer)];
            if (len <= 8) {
                if (sel[i] == 1)
                    sprintf(s," %s |","AUTO");
                else if (sel[i] == 2)
                    sprintf(s," %s |","MAN");
                else if (sel[i] == 3)
                    sprintf(s," %s |","OFF");
                else
                    sprintf(s," %s |","OVRD");
            }
            else {
                if (sel[i] == 1)
                    sprintf(s," %s|","AUT");
                else if (sel[i] == 2)
                    sprintf(s," %s|","MAN");
                else if (sel[i] == 3)
                    sprintf(s," %s|","OFF");
                else
                    sprintf(s," %s|","ERR");            
            }
        }
    }

    // Extract string conf
    void aMG_Extract_Conf_Str (const char *str, const char *head, const char *tail, char *out, int out_len)
    {
      int len;
      char *s, *p;
      
      if (!out || (out_len < 1))
        return;

      out [0] = '\0';
      s = strstr (str, head);
      if (!s) return;

      s += strlen(head);
      p = strstr (s, tail);
      len = p - s;

      if (len >= out_len)
        len = (out_len-1);

      memcpy (out, s, len);
      out [len] = '\0';
    }

    AMG_POST_DATA_STRUCT aMG_Post_Data_Struct;

    typedef enum
    {
      UPLOAD_DATA_SESSION_ACQUIRE = 0,
      UPLOAD_DATA_SYNC_SETTING, // Downlaod setting to file
      UPLOAD_DATA_READ_FILE, // Read setting from file
      UPLOAD_DATA_PROCESSING,

      UPLOAD_DATA_UNLOCK,      

      UPLOAD_DATA_SUCCESS,
      UPLOAD_DATA_ERROR,
      UPLOAD_DATA_TIMEOUT
      
    } UPLOAD_DATA_STATE;

    // data26 - data type float array 26 elements.
    // data3 - data type uint32 array 3 elements.
    // uploading_type - 0:Data, 1: Seting, 2: System message
    STA_HTTP_STATUS aMG_Upload_Data (uint8_t *session, uint8_t uploading_type, uint32_t channel, const char *str)
    {
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static UPLOAD_DATA_STATE upload_state = UPLOAD_DATA_SESSION_ACQUIRE;
        static UPLOAD_DATA_STATE upload_state_last = UPLOAD_DATA_SESSION_ACQUIRE;

        static uint8_t upload_status_error = 0;
        static uint8_t upload_status_timeout = 0;
 
        STA_HTTP_STATUS tmp_sta;
        UC15_STATUS uc15_sta;
        uint8_t on_enter;

        char *a_server_url = 0, *g_server_script_id = 0, *g_server_setting_id = 0;

        char tmp_buffer [1024];

        if (upload_state_last != upload_state)
        {
            on_enter = 1;
            upload_state_last = upload_state;
        }
        else { on_enter = 0; }

        // Check upload type
        switch (uploading_type) 
        {
            case 0: // Upload data
            case 1: // Upload setting
            case 2: // Upload system message
            case 3: // Upload setting version list
                break;
            default: // Invalid
                return STA_HTTP_ERROR;
        }

        // State processing
        switch (upload_state)
        {
            case UPLOAD_DATA_SESSION_ACQUIRE:
                upload_status_error = 0;
                upload_status_timeout = 0;
                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    upload_state = UPLOAD_DATA_SYNC_SETTING;
                }
                break;

            case UPLOAD_DATA_SYNC_SETTING:
                tmp_sta = aMG_Sync_Master_Setting();
                if (tmp_sta == STA_HTTP_SUCCESS)
                    upload_state = UPLOAD_DATA_READ_FILE;
                else if (tmp_sta == STA_HTTP_ERROR)
                    upload_state = UPLOAD_DATA_ERROR;
                else if (tmp_sta != STA_HTTP_BUSY)
                    upload_state = UPLOAD_DATA_TIMEOUT;
                break;

            case UPLOAD_DATA_READ_FILE:
                uc15_sta = uc15_atcmd_readtextfile (on_enter, MASTER_SETTING_DOWNLOAD_FILENAME, 0, UC15_PROC_BUFFER_SIZE, uc15_proc_buffer);
                if (uc15_sta == UC15_OK)
                {
                    int len = 0;
                    char *p,*q;

                    // 

                    p = 0; q = 0;

                    // XXX_ACTION
                    if (uploading_type == 0) { // Data
                        p = strstr (uc15_proc_buffer,"UPLOAD_DATA_ACTION:");
                        if (p) p += strlen("UPLOAD_DATA_ACTION:");
                    }
                    else if (uploading_type == 1) { // Setting
                      // --- Google ---
                      if (UC15_Module_Pwrcmd.Active_Server_Idx == 1) {
                        char *script_id_buffer = &tmp_buffer[0];
                        char *setting_id_buffer = &tmp_buffer[sizeof(tmp_buffer)>>1];

                        aMG_Extract_Conf_Str (uc15_proc_buffer, "G_SERVER_SCRIPT_ID:", "\\", script_id_buffer, sizeof(tmp_buffer)>>1);
                        aMG_Extract_Conf_Str (uc15_proc_buffer, "G_SERVER_SETTING_ID:", "\\", setting_id_buffer, sizeof(tmp_buffer)>>1);

                        if (script_id_buffer[0] && setting_id_buffer[0]) {
                          %assign tmp ="%"
                          sprintf (uc15_proc_buffer,
                            "UPLOAD_SETTING_ACTION:https://script.google.com/macros/s/%<tmp>s/exec\\nUPLOAD_SETTING_FORMAT:ssid=%<tmp>s&action=setting&${setting}\\n",
                            script_id_buffer, setting_id_buffer);
                        }
                      }

                      // --- Aimagin ---
                      else if (UC15_Module_Pwrcmd.Active_Server_Idx == 2) {
                        // TODO:
                        //

                      }

                      // --- Default ---
                      p = strstr (uc15_proc_buffer,"UPLOAD_SETTING_ACTION:");
                      if (p) p += strlen("UPLOAD_SETTING_ACTION:");
                    }
                    else if (uploading_type == 2) { // System message
                        p = strstr (uc15_proc_buffer,"SYS_MSG_ACTION:");
                        if (p) p += strlen("SYS_MSG_ACTION:");                        
                    }
                    else if (uploading_type == 3) { // Setting version list
                      // --- Google ---
                      if (UC15_Module_Pwrcmd.Active_Server_Idx == 1) {
                        char *script_id_buffer = &tmp_buffer[0];
                        char *setting_id_buffer = &tmp_buffer[sizeof(tmp_buffer)>>1];

                        aMG_Extract_Conf_Str (uc15_proc_buffer, "G_SERVER_SCRIPT_ID:", "\\", script_id_buffer, sizeof(tmp_buffer)>>1);
                        aMG_Extract_Conf_Str (uc15_proc_buffer, "G_SERVER_SETTING_ID:", "\\", setting_id_buffer, sizeof(tmp_buffer)>>1);

                        if (script_id_buffer[0] && setting_id_buffer[0]) {
                          %assign tmp ="%"
                          sprintf (uc15_proc_buffer,
                            "UPLOAD_VERSION_ACTION:https://script.google.com/macros/s/%<tmp>s/exec\\nUPLOAD_VERSION_FORMAT:ssid=%<tmp>s&action=version&${version}\\n",
                            script_id_buffer, setting_id_buffer);
                        }
                      }

                      // --- Aimagin ---
                      else if (UC15_Module_Pwrcmd.Active_Server_Idx == 2) {
                        // TODO:
                        //

                      }                        

                      // --- Default ---
                      p = strstr (uc15_proc_buffer,"UPLOAD_VERSION_ACTION:");
                      if (p) p += strlen("UPLOAD_VERSION_ACTION:");                        
                    }
                    else {}

                    if (p) q = strstr (p,"\\");
                    if (p && q)
                    {
                        len = q - p;
                        memcpy(app_proc_url, p, len);
                        app_proc_url[len] = '\0';

                        // Output buffer
                        app_proc_data [0] = '\0';

                        // XXX_FORMAT
                        p = 0; q = 0;
                        if (uploading_type == 0) { // Data
                            p = strstr (uc15_proc_buffer, "UPLOAD_DATA_FORMAT:");
                            if (p) p+= strlen("UPLOAD_DATA_FORMAT:");
                        }
                        else if (uploading_type == 1) { // Setting
                            p = strstr (uc15_proc_buffer, "UPLOAD_SETTING_FORMAT:");
                            if (p) p+= strlen("UPLOAD_SETTING_FORMAT:");
                        }
                        else if (uploading_type == 2) { // System message
                            p = strstr (uc15_proc_buffer, "SYS_MSG_FORMAT:");
                            if (p) p+= strlen("SYS_MSG_FORMAT:");
                        }
                        else if (uploading_type == 3) { // Setting version
                            p = strstr (uc15_proc_buffer, "UPLOAD_VERSION_FORMAT:");
                            if (p) p+= strlen("UPLOAD_VERSION_FORMAT:");
                        }
                        else {}

                        if (p) q = strstr (p,"\\");
                        if (p && q)
                        {
                            char *s;
                            int i;
                            len = q - p;

                            // Check buffer size
                            if (len >= sizeof(tmp_buffer))
                                len =  sizeof(tmp_buffer) - 1;
                            memcpy(tmp_buffer, p, len);
                            tmp_buffer[len] = '\0'; // upload format

                            s = (char *)tmp_buffer;
                            while (*s)
                            {
                                p = strstr (s, "${");
                                if (p)
                                {
                                    if (p > s)
                                    {
                                       int dlen = strlen(app_proc_data);
                                       memcpy(&app_proc_data[dlen], s, p-s);
                                       app_proc_data[dlen + (p-s)] = '\0';
                                       s+= (p-s);
                                    }
                                    p += 2;
                                    q = strstr (p,"}");
                                    if (q)
                                    {
                                        char param_name[16];
                                        s = q+1;

                                        if (((q-p) >= 16)|| ((q-p) < 1)) {
                                            // param_name
                                            strcpy (&app_proc_data[strlen(app_proc_data)], "Invalid name");
                                        }
                                        else {
                                            strncpy(param_name, p, q-p);
                                            param_name [q-p] = '\0';

                                            if (!strcmp (param_name, "datetime"))
                                                aMG_Format_Datetime (aMG_Post_Data_Struct.date_value, aMG_Post_Data_Struct.time_value,&app_proc_data[strlen(app_proc_data)]);
                                            else if (!strcmp (param_name, "light"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.lux);
                                            else if (!strcmp (param_name, "soil1"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.soil[0]);
                                            else if (!strcmp (param_name, "soil2"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.soil[1]);
                                            else if (!strcmp (param_name, "soil3"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.soil[2]);
                                            else if (!strcmp (param_name, "soil4"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.soil[3]);
                                            else if (!strcmp (param_name, "soil5"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.soil[4]);
                                            else if (!strcmp (param_name, "soil6"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.soil[5]);
                                            else if (!strcmp (param_name, "humid"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.humid);
                                            else if (!strcmp (param_name, "temp"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.temp);
                                            else if (!strcmp (param_name, "whumid"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.rsvd1);
                                            else if (!strcmp (param_name, "wtemp"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.rsvd2);
                                            else if (!strcmp (param_name, "wlevel"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.waterlevel);
                                            else if (!strcmp (param_name, "pump1"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)((aMG_Post_Data_Struct.output >> 0)&1));
                                            else if (!strcmp (param_name, "pump2"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)((aMG_Post_Data_Struct.output >> 1)&1));
                                            else if (!strcmp (param_name, "pump3"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)((aMG_Post_Data_Struct.output >> 2)&1));
                                            else if (!strcmp (param_name, "pump4"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)((aMG_Post_Data_Struct.output >> 3)&1));
                                            else if (!strcmp (param_name, "pump5"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)((aMG_Post_Data_Struct.output >> 4)&1));
                                            else if (!strcmp (param_name, "pump6"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)((aMG_Post_Data_Struct.output >> 5)&1));
                                            else if (!strcmp (param_name, "crc32"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%X", aMG_Post_Data_Struct.fw);
                                            else if (!strcmp (param_name, "mcutemp"))
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.mcutemp);
					                        else if (!strcmp (param_name, "magnetic")) 
						                        sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)(aMG_Post_Data_Struct.magnetic > 0));
					                        else if (!strcmp (param_name, "debug1")) 
						                        sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)aMG_Post_Data_Struct.debug1);
					                        else if (!strcmp (param_name, "debug2")) 
						                        sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)aMG_Post_Data_Struct.debug2);
					                        else if (!strcmp (param_name, "debug3")) 
						                        sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)aMG_Post_Data_Struct.debug3);
					                        else if (!strcmp (param_name, "debug4")) 
						                        sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)aMG_Post_Data_Struct.debug4);
					                        else if (!strcmp (param_name, "debug5")) 
						                        sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)aMG_Post_Data_Struct.debug5);
                                            else if (!strcmp (param_name, "selector"))
                                            {
                                                uint8_t sel_list [6];
                                                sel_list[0] = aMG_Post_Data_Struct.selector[0];
                                                sel_list[1] = aMG_Post_Data_Struct.selector[1];
                                                sel_list[2] = aMG_Post_Data_Struct.selector[2];
                                                sel_list[3] = aMG_Post_Data_Struct.selector[3];
                                                sel_list[4] = aMG_Post_Data_Struct.selector[4];
                                                sel_list[5] = aMG_Post_Data_Struct.selector[5];
                                                aMG_Format_SelectorSwitch (sel_list, &app_proc_data[strlen(app_proc_data)], 6);
                                            }
                                            else if (!strcmp (param_name, "selector16"))
                                            {
                                                aMG_Format_SelectorSwitch (aMG_Post_Data_Struct.selector, &app_proc_data[strlen(app_proc_data)], 16);
                                            }
                                            else if ((param_name[0] == 'p') && (strlen(param_name) <= 3))
                                            {
                                                int idx = 0;
                                                if (sscanf(param_name,"p%d", &idx) ==1) {
                                                    sprintf (&app_proc_data[strlen(app_proc_data)], "%u", (uint32_t)((aMG_Post_Data_Struct.output >> (idx-1))&1));
                                                }
                                                else {
                                                    strcpy(&app_proc_data[strlen(app_proc_data)], "Invalid");
                                                }
                                            }
                                            // Setting
                                            else if (!strcmp (param_name, "remoteid")) {
                                                char *rmid_start, *rmid_end;
                                                rmid_start = strstr (uc15_proc_buffer, "REMOTE_ID:");
                                                if (rmid_start)
                                                {
                                                    rmid_start += strlen("REMOTE_ID:");
                                                    rmid_end = strstr (rmid_start, "\\");
                                                    if (rmid_end && (rmid_end > rmid_start) && ((rmid_end - rmid_start) < 32))
                                                    {
                                                        char _tmp_id [32];
                                                        memcpy(_tmp_id, rmid_start, (rmid_end - rmid_start));
                                                        _tmp_id[(rmid_end - rmid_start)] = '\0';
                                                        strcpy(&app_proc_data[strlen(app_proc_data)], _tmp_id);
                                                    }
                                                }
                                            }
                                            else if (!strcmp (param_name, "setting")) {
                                                strcpy(&app_proc_data[strlen(app_proc_data)], str);
                                            }
                                            else if (!strcmp (param_name, "version")) {
                                                strcpy(&app_proc_data[strlen(app_proc_data)], str);
                                            }
                                            // Sysmsg
                                            else if (!strcmp (param_name, "imei")) {
                                                strcpy(&app_proc_data[strlen(app_proc_data)], (char *)UC15_Module_Info.imei);
                                            }
                                            else if (!strcmp (param_name, "builddate")) {
                                                strcpy(&app_proc_data[strlen(app_proc_data)], __DATE__ " " __TIME__);
                                            }  
                                            else if (!strcmp (param_name, "sysmsg")) {
                                                strcpy(&app_proc_data[strlen(app_proc_data)], str);
                                            }
                                            else if (!strcmp (param_name, "modinf")) {
                                                strcpy(&app_proc_data[strlen(app_proc_data)], UC15_Module_Info.module_info);
                                            }
                                            else if (!strcmp (param_name, "rssi3g")) {
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "%d", UC15_Module_Info.signal_quality);
                                            }
                                            // 'wb1','wb2','wb3','wb4','wb5',
                                            else if (!strcmp (param_name, "wb1")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.1f", aMG_Post_Data_Struct.wb[0]);
                                            }
                                            else if (!strcmp (param_name, "wb2")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.1f", aMG_Post_Data_Struct.wb[1]);
                                            }
                                            else if (!strcmp (param_name, "wb3")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.1f", aMG_Post_Data_Struct.wb[2]);
                                            }
                                            else if (!strcmp (param_name, "wb4")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.1f", aMG_Post_Data_Struct.wb[3]);
                                            }
                                            else if (!strcmp (param_name, "wb5")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.1f", aMG_Post_Data_Struct.wb[4]);
                                            }
                                            // 'wh1','wh2','wh3','wh4','wh5',
                                            else if (!strcmp (param_name, "wh1")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wh[0]);
                                            }
                                            else if (!strcmp (param_name, "wh2")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wh[1]);
                                            }
                                            else if (!strcmp (param_name, "wh3")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wh[2]);
                                            }
                                            else if (!strcmp (param_name, "wh4")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wh[3]);
                                            }
                                            else if (!strcmp (param_name, "wh5")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wh[4]);
                                            }

                                            // 'wt1','wt2','wt3','wt4','wt5',
                                            else if (!strcmp (param_name, "wt1")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wt[0]);
                                            }
                                            else if (!strcmp (param_name, "wt2")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wt[1]);
                                            }
                                            else if (!strcmp (param_name, "wt3")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wt[2]);
                                            }
                                            else if (!strcmp (param_name, "wt4")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wt[3]);
                                            }
                                            else if (!strcmp (param_name, "wt5")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.wt[4]);
                                            }

                                            // 'ws1','ws2','ws3','ws4','ws5',
                                            else if (!strcmp (param_name, "ws1")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.ws[0]);
                                            }
                                            else if (!strcmp (param_name, "ws2")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.ws[1]);
                                            }
                                            else if (!strcmp (param_name, "ws3")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.ws[2]);
                                            }
                                            else if (!strcmp (param_name, "ws4")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.ws[3]);
                                            }
                                            else if (!strcmp (param_name, "ws5")) {
                                              sprintf (&app_proc_data[strlen(app_proc_data)], "%1.2f", aMG_Post_Data_Struct.ws[4]);
                                            }

                                            else
                                            {
                                                sprintf (&app_proc_data[strlen(app_proc_data)], "Unknown:%s", param_name);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // Error
                                        strcpy(&app_proc_data[strlen(app_proc_data)], "Error");
                                        s += strlen(s); // End of search
                                    }
                                }
                                else 
                                {
                                    // End of Key search
                                    // Move reset to s
                                    strcpy(&app_proc_data[strlen(app_proc_data)], s);
                                    s += strlen(s); // End of search
                                }
                            }
                        }

                        // Upload
                        upload_state = UPLOAD_DATA_PROCESSING;
                    }
                    else
                        upload_state = UPLOAD_DATA_ERROR;
                }
                else if (uc15_sta != UC15_BUSY)
                {
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 1;
                    upload_state = UPLOAD_DATA_ERROR;
                }
                break;

            case UPLOAD_DATA_PROCESSING:
                tmp_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_POST, 1, app_proc_url, app_proc_data,"","",0,0);
	            if (tmp_sta == STA_HTTP_SUCCESS)
                    upload_state = UPLOAD_DATA_SUCCESS;
	            else if (tmp_sta == STA_HTTP_ERROR)
                    upload_state = UPLOAD_DATA_ERROR;
	            else if (tmp_sta != STA_HTTP_BUSY)
                    upload_state = UPLOAD_DATA_TIMEOUT;
                break;

            case UPLOAD_DATA_UNLOCK:
               uc15_session_release (session);
               if (upload_status_error)
                   ret = STA_HTTP_ERROR;
               else if (upload_status_timeout)
                   ret = STA_HTTP_TIMEOUT;
               else
                   ret = STA_HTTP_SUCCESS;
               upload_state = UPLOAD_DATA_SESSION_ACQUIRE; // Back
               break;

            case UPLOAD_DATA_ERROR:
                upload_status_error = 1;
                upload_state = UPLOAD_DATA_UNLOCK;         
                break;

            case UPLOAD_DATA_TIMEOUT:
                upload_status_timeout = 1;
                upload_state = UPLOAD_DATA_UNLOCK;
                break;

            case UPLOAD_DATA_SUCCESS:
                upload_state = UPLOAD_DATA_UNLOCK;
                break;
        }
        return ret;
    }

    // --- Download setting_version ---
    typedef enum
    {
      DOWNLOAD_SETTING_VERSION_SESSION_ACQUIRE = 0,
      DOWNLOAD_SETTING_VERSION_SYNC_SETTING, // Downlaod setting to file
      DOWNLOAD_SETTING_VERSION_READ_FILE, // Read setting from file
      DOWNLOAD_SETTING_VERSION_PROCESSING,

      DOWNLOAD_SETTING_VERSION_UNLOCK,      

      DOWNLOAD_SETTING_VERSION_SUCCESS,
      DOWNLOAD_SETTING_VERSION_ERROR,
      DOWNLOAD_SETTING_VERSION_TIMEOUT
      
    } DOWNLOAD_SETTING_VERSION_STATE;

    STA_HTTP_STATUS aMG_Download_Setting_Version (uint8_t *session, uint32_t *version)
    {
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static DOWNLOAD_SETTING_VERSION_STATE downloadsetting_state = DOWNLOAD_SETTING_VERSION_SESSION_ACQUIRE;
        static DOWNLOAD_SETTING_VERSION_STATE downloadsetting_state_last = DOWNLOAD_SETTING_VERSION_SESSION_ACQUIRE;

        static uint8_t downloadsetting_status_error = 0;
        static uint8_t downloadsetting_timeout = 0;
 
        STA_HTTP_STATUS tmp_sta;
        UC15_STATUS uc15_sta;
        uint8_t on_enter;

        char tmp_buffer [1024];

        if (downloadsetting_state_last != downloadsetting_state)
        {
            on_enter = 1;
            downloadsetting_state_last = downloadsetting_state;
        }
        else { on_enter = 0; }

        // State processing
        switch (downloadsetting_state)
        {
            case DOWNLOAD_SETTING_VERSION_SESSION_ACQUIRE:
                downloadsetting_status_error = 0;
                downloadsetting_timeout = 0;
                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_SYNC_SETTING;
                }
                break;

            case DOWNLOAD_SETTING_VERSION_SYNC_SETTING:
                tmp_sta = aMG_Sync_Master_Setting();
                if (tmp_sta == STA_HTTP_SUCCESS)
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_READ_FILE;
                else if (tmp_sta == STA_HTTP_ERROR)
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_ERROR;
                else if (tmp_sta != STA_HTTP_BUSY)
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_TIMEOUT;
                break;

            case DOWNLOAD_SETTING_VERSION_READ_FILE:
                uc15_sta = uc15_atcmd_readtextfile (on_enter, MASTER_SETTING_DOWNLOAD_FILENAME, 0, UC15_PROC_BUFFER_SIZE, uc15_proc_buffer);
                if (uc15_sta == UC15_OK)
                {
                    int len;
                    char *p = 0,*q = 0;
                    char *a_server_url, *g_server_script_id, *g_server_setting_id;

                    p = 0; q = 0;
                    
                    // Index 1: Google
                    // Index 2: Aimagin
                    a_server_url = strstr(uc15_proc_buffer,        "A_SERVER_URL:");
                    g_server_script_id = strstr(uc15_proc_buffer,  "G_SERVER_SCRIPT_ID:");
                    g_server_setting_id = strstr(uc15_proc_buffer, "G_SERVER_SETTING_ID:");
                    if (a_server_url)
                      a_server_url += strlen("A_SERVER_URL:");
                    if (g_server_script_id)
                      g_server_script_id +=  strlen("G_SERVER_SCRIPT_ID:");
                    if (g_server_setting_id)
                      g_server_setting_id += strlen("G_SERVER_SETTING_ID:");

                    if (a_server_url && g_server_script_id && g_server_setting_id) {
                       // Both server are valid, Switch between: 1|2
                       UC15_Module_Pwrcmd.Active_Server_Idx ++;
                       if (UC15_Module_Pwrcmd.Active_Server_Idx > 2)
                         UC15_Module_Pwrcmd.Active_Server_Idx = 1;
                    }
                    else if (a_server_url) {
                      // Only Amg server is valid
                      UC15_Module_Pwrcmd.Active_Server_Idx = 2; // AIMAGIN
                    }
                    else if (g_server_script_id && g_server_setting_id) {
                      // Only Google server is valid
                      UC15_Module_Pwrcmd.Active_Server_Idx = 1; // Google
                    }
                    else {
                      UC15_Module_Pwrcmd.Active_Server_Idx = 0; // Lagecy version, 0
                      p = strstr (uc15_proc_buffer,"DOWNLOAD_VERSION_URL:");
                      if (p) p += strlen("DOWNLOAD_VERSION_URL:");
                      if (p) q = strstr (p,"\\");
                    }

                    // --- Google ---
                    if (UC15_Module_Pwrcmd.Active_Server_Idx == 1) {
                      char *script_id_buffer = &app_proc_url[0];
                      char *setting_id_buffer = &app_proc_url[APP_PROC_URL_SIZE>>1];

                      // Script ID                  
                      q = strstr (g_server_script_id,"\\");
                      if (q)
                        len = (q - g_server_script_id);
                      else
                        len = strlen(g_server_script_id);
                      if (len >= (APP_PROC_URL_SIZE>>1))
                        len = (APP_PROC_URL_SIZE>>1)-1;
                      memcpy(script_id_buffer, g_server_script_id, len);
                      script_id_buffer[len] = '\0';
                      
                      // Setting ID
                      q = strstr (g_server_setting_id,"\\");
                      if (q)
                        len = (q - g_server_setting_id);
                      else
                        len = strlen(g_server_setting_id);
                      if (len >= (APP_PROC_URL_SIZE>>1))
                        len = (APP_PROC_URL_SIZE>>1)-1;
                      memcpy(setting_id_buffer, g_server_setting_id, len);
                      setting_id_buffer[len] = '\0';                      

                      // Combine
                      %assign tmp = "%s"
                      sprintf (uc15_proc_buffer,
                               "https://script.google.com/macros/s/%<tmp>/exec?ssid=%<tmp>&action=version\\n",
                               script_id_buffer, setting_id_buffer
                               );
                      p = (char *)uc15_proc_buffer;
                      if (p) q = strstr (p,"\\");
                    } 
                    // --- Aimagin ---
                    else if (UC15_Module_Pwrcmd.Active_Server_Idx == 2) {
                      // Aimagin
                      q = strstr (a_server_url,"\\");
                      if (q)
                        len = (q - a_server_url);
                      else
                        len = strlen(a_server_url);
                      if (len >= APP_PROC_URL_SIZE)
                        len = APP_PROC_URL_SIZE-1;

                      // Combine
                      memcpy (uc15_proc_buffer, a_server_url, len);
                      uc15_proc_buffer[len] = '\0';
                      if (len > 0) {
                        if (uc15_proc_buffer[len-1] != '/') {
                          uc15_proc_buffer[len] = '/';
                          len++;
                          uc15_proc_buffer[len] = '\0';
                        }
                      }
                      strcpy (&uc15_proc_buffer[strlen(uc15_proc_buffer)], "version");
                      p = (char *)uc15_proc_buffer;
                      if (p) q = strstr (p,"\\");
                    }

                    if (p && q)
                    {
                        char *s;
                        len = q - p;
                        memcpy(tmp_buffer, p, len);
                        tmp_buffer[len] = '\0';

                        // Output buffer
                        app_proc_data [0] = '\0';
                        app_proc_url [0] = '\0';

                        // Pre-processing
                        s = (char *)tmp_buffer;
                        while (*s) {
                            p = strstr (s, "${");
                            if (p) {
                                if (p > s) {
                                    int dlen = strlen(app_proc_url);
                                    memcpy(&app_proc_url[dlen], s, p-s);
                                    app_proc_url[dlen + (p-s)] = '\0';
                                    s+= (p-s);
                                }
                                p += 2;
                                q = strstr (p,"}");
                                if (q) {
                                    char param_name[16];
                                    s = q+1;

                                    if (((q-p) >= 16)|| ((q-p) < 1)) {
                                        // param_name
                                        strcpy (&app_proc_url[strlen(app_proc_url)], "Invalid name");
                                    }
                                    else {
                                        strncpy(param_name, p, q-p);
                                        param_name [q-p] = '\0';

                                        if (!strcmp (param_name, "channel"))
                                            sprintf (&app_proc_url[strlen(app_proc_url)], "%u", (uint32_t)-1);
                                        else
                                        {
                                            sprintf (&app_proc_url[strlen(app_proc_url)], "Unknown:%s", param_name);
                                        }
                                    }
                                }
                                else
                                {
                                    // Error
                                    strcpy(&app_proc_url[strlen(app_proc_url)], "Error");
                                    s += strlen(s); // End of search
                                }
                            }
                            else 
                            {
                                // End of Key search
                                // Move reset to s
                                strcpy(&app_proc_url[strlen(app_proc_url)], s);
                                s += strlen(s); // End of search
                            }
                        }

                        // Upload
                        downloadsetting_state = DOWNLOAD_SETTING_VERSION_PROCESSING;
                    }
                    else
                    {
                        downloadsetting_state = DOWNLOAD_SETTING_VERSION_ERROR;
                    }
                }
                else if (uc15_sta == UC15_ERROR)
                {
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 1;
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_ERROR;
                }
                else if (uc15_sta != UC15_BUSY)
                {
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 1;
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_TIMEOUT;
                }
                break;

            case DOWNLOAD_SETTING_VERSION_PROCESSING:
                tmp_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_GET, 1, app_proc_url, app_proc_data, "version=", "", tmp_buffer, sizeof(tmp_buffer));
	            if (tmp_sta == STA_HTTP_SUCCESS) {
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_SUCCESS; // Success
                    {
                        int i;
                        char *p;
                        p = tmp_buffer;
                        i = 0;
                        while (p && *p && (i<32)) {
                            sscanf (p,"%u",&version[i]);
                            i++;
                            p = strstr(p,",");
                            if (p) p++;
                        }
                    }
                }
	            else if (tmp_sta == STA_HTTP_ERROR)
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_ERROR;
	            else if (tmp_sta != STA_HTTP_BUSY)
                    downloadsetting_state = DOWNLOAD_SETTING_VERSION_TIMEOUT;
                break;

            case DOWNLOAD_SETTING_VERSION_UNLOCK:
               uc15_session_release (session);
               if (downloadsetting_status_error) {
                   ret = STA_HTTP_ERROR;
               }
               else if (downloadsetting_timeout) {
                   ret = STA_HTTP_TIMEOUT;
               }
               else
               {
                   ret = STA_HTTP_SUCCESS;
               }
               downloadsetting_state = DOWNLOAD_SETTING_VERSION_SESSION_ACQUIRE; // Back
               break;

            case DOWNLOAD_SETTING_VERSION_ERROR:
                downloadsetting_status_error = 1;
                downloadsetting_state = DOWNLOAD_SETTING_VERSION_UNLOCK;         
                break;

            case DOWNLOAD_SETTING_VERSION_TIMEOUT:
                downloadsetting_timeout = 1;
                downloadsetting_state = DOWNLOAD_SETTING_VERSION_UNLOCK;
                break;

            case DOWNLOAD_SETTING_VERSION_SUCCESS:
                downloadsetting_state = DOWNLOAD_SETTING_VERSION_UNLOCK;
                break;
        }
        return ret;
    }

    // --- Download setting ---
    typedef enum
    {
      DOWNLOAD_SETTING_SESSION_ACQUIRE = 0,
      DOWNLOAD_SETTING_SYNC_SETTING, // Downlaod setting to file
      DOWNLOAD_SETTING_READ_FILE, // Read setting from file
      DOWNLOAD_SETTING_PROCESSING,

      DOWNLOAD_SETTING_UNLOCK,      

      DOWNLOAD_SETTING_SUCCESS,
      DOWNLOAD_SETTING_ERROR,
      DOWNLOAD_SETTING_TIMEOUT
      
    } DOWNLOAD_SETTING_STATE;

    STA_HTTP_STATUS aMG_Download_Setting (uint8_t *session, uint8_t channel, char *output, int32_t output_len, uint16_t *return_len)
    {
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static DOWNLOAD_SETTING_STATE downloadsetting_state = DOWNLOAD_SETTING_SESSION_ACQUIRE;
        static DOWNLOAD_SETTING_STATE downloadsetting_state_last = DOWNLOAD_SETTING_SESSION_ACQUIRE;

        static uint8_t downloadsetting_status_error = 0;
        static uint8_t downloadsetting_timeout = 0;
 
        STA_HTTP_STATUS tmp_sta;
        UC15_STATUS uc15_sta;
        uint8_t on_enter;

        char tmp_buffer [1024];
        // Return len default 0
        *return_len = 0;

        if (downloadsetting_state_last != downloadsetting_state)
        {
            on_enter = 1;
            downloadsetting_state_last = downloadsetting_state;
        }
        else { on_enter = 0; }

        // State processing
        switch (downloadsetting_state)
        {
            case DOWNLOAD_SETTING_SESSION_ACQUIRE:
                downloadsetting_status_error = 0;
                downloadsetting_timeout = 0;
                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    downloadsetting_state = DOWNLOAD_SETTING_SYNC_SETTING;
                }
                break;

            case DOWNLOAD_SETTING_SYNC_SETTING:
                tmp_sta = aMG_Sync_Master_Setting();
                if (tmp_sta == STA_HTTP_SUCCESS)
                    downloadsetting_state = DOWNLOAD_SETTING_READ_FILE;
                else if (tmp_sta == STA_HTTP_ERROR)
                    downloadsetting_state = DOWNLOAD_SETTING_ERROR;
                else if (tmp_sta != STA_HTTP_BUSY)
                    downloadsetting_state = DOWNLOAD_SETTING_TIMEOUT;
                break;

            case DOWNLOAD_SETTING_READ_FILE:
                uc15_sta = uc15_atcmd_readtextfile (on_enter, MASTER_SETTING_DOWNLOAD_FILENAME, 0, UC15_PROC_BUFFER_SIZE, uc15_proc_buffer);
                if (uc15_sta == UC15_OK)
                {
                    int len;
                    char *p,*q;

                    p = 0; q = 0;

                    // --- Google ---
                    if (UC15_Module_Pwrcmd.Active_Server_Idx == 1) {
                        char *script_id_buffer = &tmp_buffer[0];
                        char *setting_id_buffer = &tmp_buffer[sizeof(tmp_buffer)>>1];

                        aMG_Extract_Conf_Str (uc15_proc_buffer, "G_SERVER_SCRIPT_ID:", "\\", script_id_buffer, sizeof(tmp_buffer)>>1);
                        aMG_Extract_Conf_Str (uc15_proc_buffer, "G_SERVER_SETTING_ID:", "\\", setting_id_buffer, sizeof(tmp_buffer)>>1);

                        if (script_id_buffer[0] && setting_id_buffer[0]) {
                          %assign tmp ="%"
                          sprintf (uc15_proc_buffer,
                            "DOWNLOAD_SETTING_URL:https://script.google.com/macros/s/%<tmp>s/exec?ssid=%<tmp>s&zoneid=${channel}&action=setting\\n",
                            script_id_buffer, setting_id_buffer);
                        }
                    }

                    // --- Aimagin ---
                    else if (UC15_Module_Pwrcmd.Active_Server_Idx == 2) {
                        // TODO:
                        //

                    }

                    p = strstr (uc15_proc_buffer,"DOWNLOAD_SETTING_URL:");
                    if (p) p += strlen("DOWNLOAD_SETTING_URL:");
                    if (p) q = strstr (p,"\\");

                    if (p && q)
                    {
                        char *s;
                        len = q - p;
                        memcpy(tmp_buffer, p, len);
                        tmp_buffer[len] = '\0';

                        // Output buffer
                        app_proc_data [0] = '\0';
                        app_proc_url [0] = '\0';

                        // Pre-processing
                        s = (char *)tmp_buffer;
                        while (*s) {
                            p = strstr (s, "${");
                            if (p) {
                                if (p > s) {
                                    int dlen = strlen(app_proc_url);
                                    memcpy(&app_proc_url[dlen], s, p-s);
                                    app_proc_url[dlen + (p-s)] = '\0';
                                    s+= (p-s);
                                }
                                p += 2;
                                q = strstr (p,"}");
                                if (q)
                                {
                                    char param_name[16];
                                    s = q+1;

                                    if (((q-p) >= 16)|| ((q-p) < 1)) {
                                        // param_name
                                        strcpy (&app_proc_url[strlen(app_proc_url)], "Invalid name");
                                    }
                                    else {
                                        strncpy(param_name, p, q-p);
                                        param_name [q-p] = '\0';

                                        if (!strcmp (param_name, "channel"))
                                            sprintf (&app_proc_url[strlen(app_proc_url)], "%u", channel);
                                        else
                                        {
                                            sprintf (&app_proc_url[strlen(app_proc_url)], "Unknown:%s", param_name);
                                        }
                                    }
                                }
                                else {
                                    // Error
                                    strcpy(&app_proc_url[strlen(app_proc_url)], "Error");
                                    s += strlen(s); // End of search
                                }
                            }
                            else 
                            {
                                // End of Key search
                                // Move reset to s
                                strcpy(&app_proc_url[strlen(app_proc_url)], s);
                                s += strlen(s); // End of search
                            }
                        }

                        // Upload
                        downloadsetting_state = DOWNLOAD_SETTING_PROCESSING;
                    }
                    else
                    {
                        downloadsetting_state = DOWNLOAD_SETTING_ERROR;
                    }
                }
                else if (uc15_sta == UC15_ERROR)
                {
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 1;
                    downloadsetting_state = DOWNLOAD_SETTING_ERROR;
                }
                else if (uc15_sta != UC15_BUSY)
                {
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 1;
                    downloadsetting_state = DOWNLOAD_SETTING_TIMEOUT;
                }
                break;

            case DOWNLOAD_SETTING_PROCESSING:
                tmp_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_GET, 1, app_proc_url, app_proc_data, "", "", tmp_buffer, sizeof(tmp_buffer)); // output, output_len);
	            if (tmp_sta == STA_HTTP_SUCCESS) {
					char *p;
					int i;
					uint32_t zone_id = 0;
					uint32_t mode_id = 0;
					uint32_t setting_version = 0;
					uint32_t mode1_enable_list[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
					uint32_t mode1_start_list[20];
					uint32_t mode1_runtime_list[20];
					uint32_t mode1_day_list[20];
					uint32_t mode2_timer = 600;
					uint32_t mode2_runtime = 30;
					uint32_t mode2_repeat = 1;
					uint32_t mode3_on = 50;
					uint32_t mode3_off = 70;
						
					// zone_id=
					p =	string_follow_with(tmp_buffer,"zone_id=");
					if (p) sscanf(p,"%u",&zone_id);
					// "mode_id="
					p =	string_follow_with(tmp_buffer,"mode_id=");
					if (p) sscanf(p,"%u",&mode_id);
					// "ver="
					p =	string_follow_with(tmp_buffer,"ver=");
					if (p) sscanf(p,"%u",&setting_version);
					// mode1_enable=
					p =	string_follow_with(tmp_buffer,"mode1_enable=");
					i = 0;
					while (p && *p && (i<20)) {
						if (!sscanf(p,"%u", &mode1_enable_list[i]))
							mode1_enable_list[i] = 0; // Parse error, disable it
						p =	string_follow_with(p,",");
						i++;						
					}
					// mode1_start=
					p =	string_follow_with(tmp_buffer,"mode1_start=");
					i = 0;
					while (p && *p && (i<20)) {
						sscanf(p,"%u", &mode1_start_list[i]);
						p =	string_follow_with(p,",");
						i++;						
					}
					// mode1_runtime=
					p =	string_follow_with(tmp_buffer,"mode1_runtime=");
					i = 0;
					while (p && *p && (i<20)) {
						sscanf(p,"%u", &mode1_runtime_list[i]);
						p =	string_follow_with(p,",");
						i++;
					}
					// mode1_day=
					p =	string_follow_with(tmp_buffer,"mode1_day=");
					i = 0;
					while (p && *p && (i<20)) {
						sscanf(p,"%u", &mode1_day_list[i]);
						mode1_day_list[i] &= 0xFF;
						p =	string_follow_with(p,",");
						i++;
					}
					// mode2_timer=
					p =	string_follow_with(tmp_buffer,"mode2_timer=");
					if (p) sscanf(p,"%u",&mode2_timer);	
					// mode2_runtime=
					p =	string_follow_with(tmp_buffer,"mode2_runtime=");
					if (p) sscanf(p,"%u",&mode2_runtime);					
					// mode2_repeat=
					p =	string_follow_with(tmp_buffer,"mode2_repeat=");
					if (p) sscanf(p,"%u",&mode2_repeat);			
					// mode3_on=
					p =	string_follow_with(tmp_buffer,"mode3_on=");
					if (p) sscanf(p,"%u",&mode3_on);	
					// mode3_off=
					p =	string_follow_with(tmp_buffer,"mode3_off=");
					if (p) sscanf(p,"%u",&mode3_off);

					output[0] = '\0';
					sprintf(&output[strlen(output)], "SYNCSETTING%u,%X,%X", zone_id, mode_id, setting_version);
					for (i=0; i<20; i++)
					{
						uint32_t value;
						
						value = mode1_start_list[i] & 0x00FFFFFF;
						if (mode1_enable_list[i]==0)
							value |= 0x01000000;
						sprintf(&output[strlen(output)], ",%X",value);
						
						value = mode1_runtime_list[i] & 0x00FFFFFF;
						value |= (uint32_t)mode1_day_list[i] <<24;
						sprintf(&output[strlen(output)], ",%X",value);
					}
					
					//
					sprintf(&output[strlen(output)], ",%X", (mode2_timer & 0x007FFFFF) | (uint32_t)(mode2_repeat > 0)<<23);
					sprintf(&output[strlen(output)], ",%X", (mode2_runtime & 0x007FFFFF));
					
					// 
					sprintf(&output[strlen(output)], ",%X", (uint32_t)mode3_off<<16 | (uint32_t)mode3_on);
					
					// Reserver
					sprintf(&output[strlen(output)], ",%X", 0);
					sprintf(&output[strlen(output)], ",%X", 0);
					sprintf(&output[strlen(output)], ",%X", 0);

					sprintf(&output[strlen(output)], "\r\n");

                    downloadsetting_state = DOWNLOAD_SETTING_SUCCESS; // Success
                }
	            else if (tmp_sta == STA_HTTP_ERROR)
                    downloadsetting_state = DOWNLOAD_SETTING_ERROR;
	            else if (tmp_sta != STA_HTTP_BUSY)
                    downloadsetting_state = DOWNLOAD_SETTING_TIMEOUT;
                break;

            case DOWNLOAD_SETTING_UNLOCK:
               uc15_session_release (session);
               if (downloadsetting_status_error) {
                   ret = STA_HTTP_ERROR;
               }
               else if (downloadsetting_timeout) {
                   ret = STA_HTTP_TIMEOUT;
               }
               else
               {
                   ret = STA_HTTP_SUCCESS;
                   *return_len = strlen (output);
               }
               downloadsetting_state = DOWNLOAD_SETTING_SESSION_ACQUIRE; // Back
               break;

            case DOWNLOAD_SETTING_ERROR:
                downloadsetting_status_error = 1;
                downloadsetting_state = DOWNLOAD_SETTING_UNLOCK;         
                break;

            case DOWNLOAD_SETTING_TIMEOUT:
                downloadsetting_timeout = 1;
                downloadsetting_state = DOWNLOAD_SETTING_UNLOCK;
                break;

            case DOWNLOAD_SETTING_SUCCESS:
                downloadsetting_state = DOWNLOAD_SETTING_UNLOCK;
                break;
        }
        return ret;
    }

    // --- download firmware ---
    typedef enum
    {
      DOWNLOAD_FW_SESSION_ACQUIRE = 0,
      DOWNLOAD_FW_GET_SETTING, // Downlaod setting to buffer

      DOWNLOAD_FW_FLASHCMD_CURRENT_CRC32,
      DOWNLOAD_FW_FLASHCMD_CURRENT_CRC32_RETRY,
      DOWNLOAD_FW_GET_FILE,
      DOWNLOAD_FW_VALIDATE_FILE,

      DOWNLOAD_FW_FLASH_ERASE,
      DOWNLOAD_FW_FLASH_ERASE_RETRY,

      DOWNLOAD_FW_CHECK_PROGRESS,

      DOWNLOAD_FW_READ_PACKAGE,
      DOWNLOAD_FW_FLASH_WRITE,
      DOWNLOAD_FW_FLASH_WRITE_RETRY,

      DOWNLOAD_FW_RESET,
      DOWNLOAD_FW_RESET_RETRY,
      DOWNLOAD_FW_RESET_WAIT,

      DOWNLOAD_FW_VALIDATE, // Request new CRC
      DOWNLOAD_FW_VALIDATE_RETRY,


      DOWNLOAD_FW_UNLOCK,      

      DOWNLOAD_FW_SUCCESS,
      DOWNLOAD_FW_ERROR,
      DOWNLOAD_FW_TIMEOUT
      
    } DOWNLOAD_FW_STATE;

    const char MASTER_DOWNLOAD_FW_QUERY[] = "https://doc.google.com/spreadsheets/d/1hjfRfUEjFT7ZMEiOz85j1jIglbDDRAjm9YRqF8Va88g/gviz/tq?tq=select+F+where+A=%"
                                        "%27%s%"
                                        "%27";
    #define UPGRADE_FLASH_CMD_GET_MAINCRC           240
    #define UPGRADE_FLASH_CMD_ERASE                 241
    #define UPGRADE_FLASH_CMD_RESET                 242
    #define UPGRADE_FLASH_CMD_GET_TEMPCRC           243
    #define UPGRADE_FLASH_CMD_GET_TEMPSIGNATURE     244
    #define UPGRADE_FLASH_CMD_WRITE_FLASH           245

    #define UPGRADE_FLASH_STATUS_BUSY               255
    #define UPGRADE_FLASH_STATUS_SUCCESS            0

    #define UPGRADE_FW_DOWNLOAD_FILENAME            "fw.bin"
    #define UPGRADE_FW_DOWNLOAD_FILESIZE            (64*1024UL)

    STA_HTTP_STATUS aMG_Download_Firmware (uint8_t *session, const char *target, 
        uint32_t flash_sta, uint32_t signature, uint32_t flash_data_count, uint32_t *flash_cmd,
        uint32_t *flash_offset, uint32_t *flash_data)
    {
        static SYS_TIMER_STRUCT timer_ms = {0, 0};
        static uint32_t retry_count = 0;

        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static DOWNLOAD_FW_STATE download_fw_state = DOWNLOAD_FW_SESSION_ACQUIRE;
        static DOWNLOAD_FW_STATE download_fw_state_last = DOWNLOAD_FW_SESSION_ACQUIRE;

        static uint8_t download_fw_status_error = 0;
        static uint8_t download_fw_timeout = 0;

        static uint32_t setting_upgrade_fw_enable = 0;
        static uint32_t setting_upgrade_fw_crc = 0;

        static uint32_t flash_write_offset = 0;
        static uint32_t flash_total_size = 0;
 
        STA_HTTP_STATUS tmp_sta;
        UC15_STATUS uc15_sta;
        uint8_t on_enter;

        char tmp_buffer [1024];

        *flash_cmd = 0;
        flash_total_size = UPGRADE_FW_DOWNLOAD_FILESIZE;

        if (download_fw_state_last != download_fw_state)
        {
            on_enter = 1;
            download_fw_state_last = download_fw_state;
        }
        else { on_enter = 0; }

        // State processing
        switch (download_fw_state)
        {
            case DOWNLOAD_FW_SESSION_ACQUIRE:
                download_fw_status_error = 0;
                download_fw_timeout = 0;

                flash_write_offset = 0;

                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    download_fw_state = DOWNLOAD_FW_GET_SETTING;
                }
                break;
            
            case DOWNLOAD_FW_GET_SETTING:
                sprintf (tmp_buffer, MASTER_DOWNLOAD_FW_QUERY, (char *)UC15_Module_Info.imei);
	            tmp_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_GET, 1, tmp_buffer,
                          (char *)0, target, "\\", app_proc_data, (uint16_t)sizeof(app_proc_data));
                if (tmp_sta == STA_HTTP_SUCCESS)
                {
                    char *s, *p;
                    setting_upgrade_fw_enable = 0;
                    setting_upgrade_fw_crc = 0;

                    s = strstr (app_proc_data, "Enable=");
                    if (s && (sscanf(s, "Enable=%u,Crc=%X,", &setting_upgrade_fw_enable, &setting_upgrade_fw_crc) == 2))
                    {
                        // Check new upgrade available
                        if (setting_upgrade_fw_enable)
                        {
                            app_proc_url [0] = '\0';
                            // Store file url
                            p = strstr(s, "Url=");
                            if (p) {
                                p += strlen("Url=");
                                strcpy(app_proc_url, p);

                                // Next, get current crc32
                                download_fw_state = DOWNLOAD_FW_FLASHCMD_CURRENT_CRC32;
                                
                                // Reset retry count
                                retry_count = 0;
                            }
                            else {
                                download_fw_state = DOWNLOAD_FW_ERROR;
                            }
                        }
                        else {
                            download_fw_state = DOWNLOAD_FW_SUCCESS;
                        }
                    }
                    else
                    {
                        download_fw_state = DOWNLOAD_FW_ERROR;
                    }
                }
	            else if (tmp_sta == STA_HTTP_ERROR)
                    download_fw_state = DOWNLOAD_FW_ERROR;
	            else if (tmp_sta != STA_HTTP_BUSY)
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;

            case DOWNLOAD_FW_FLASHCMD_CURRENT_CRC32:
                if (on_enter)
                {
                    *flash_cmd = UPGRADE_FLASH_CMD_GET_MAINCRC;
                    SysTimer_Start(&timer_ms, 2000);
                }
                else
                {
                    if ((flash_sta == UPGRADE_FLASH_STATUS_BUSY) || (flash_sta == 0))
                    {
                        // Timeout check
                        if (SysTimer_IsTimeout(&timer_ms))
                            download_fw_state = DOWNLOAD_FW_FLASHCMD_CURRENT_CRC32_RETRY;
                    }
                    else if (flash_sta == setting_upgrade_fw_crc)
                    {
                        // Firmware Enable, no upgrade needded
                        download_fw_state = DOWNLOAD_FW_SUCCESS;
                    }
                    else
                    {
                        // Enable, need upgrade
                        download_fw_state = DOWNLOAD_FW_GET_FILE;
                    }
                }
                break;

            case DOWNLOAD_FW_FLASHCMD_CURRENT_CRC32_RETRY:
                if (++ retry_count <= 8)
                    download_fw_state = DOWNLOAD_FW_FLASHCMD_CURRENT_CRC32;
                else
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;

            case DOWNLOAD_FW_GET_FILE:
                tmp_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_DOWNLOAD, 1, app_proc_url, UPGRADE_FW_DOWNLOAD_FILENAME, "","", 0, 0);
                if (tmp_sta == STA_HTTP_SUCCESS)
                    download_fw_state = DOWNLOAD_FW_VALIDATE_FILE; // Success
                else if (tmp_sta == STA_HTTP_ERROR)
                    download_fw_state = DOWNLOAD_FW_ERROR;
                else if (tmp_sta != STA_HTTP_BUSY)
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;

            case DOWNLOAD_FW_VALIDATE_FILE:
            {
		        uint32_t reading_size, file_size;
                uint32_t file_emb_crc, file_emb_signature;
	
		        uc15_sta = uc15_atcmd_readfile (on_enter, UPGRADE_FW_DOWNLOAD_FILENAME, UPGRADE_FW_DOWNLOAD_FILESIZE-8, 8, (uint8_t *)tmp_buffer, &reading_size, &file_size);
                if (uc15_sta == UC15_OK)
                {
                    memcpy(&file_emb_crc, &tmp_buffer[4], 4); // CRC
                    memcpy(&file_emb_signature, &tmp_buffer[0], 4); // Signature

                    if ((file_size == UPGRADE_FW_DOWNLOAD_FILESIZE) 
                        && (file_emb_crc == setting_upgrade_fw_crc)
                        && (file_emb_signature == signature))
                    {
                        // Clear retry count
                        retry_count = 0;
                        
                        // Erase flash
                        download_fw_state = DOWNLOAD_FW_FLASH_ERASE;
                    }
                    else
                    {
                        download_fw_state = DOWNLOAD_FW_ERROR;
                    }
                }
                else if (uc15_sta == UC15_ERROR)
                    download_fw_state = DOWNLOAD_FW_ERROR;
				else if (uc15_sta != UC15_BUSY)
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;
            }

            case DOWNLOAD_FW_FLASH_ERASE:
                if (on_enter)
                {
                    // Start timer for timeout check
                    SysTimer_Start(&timer_ms, 3000);

                    // Execute
                    *flash_cmd = UPGRADE_FLASH_CMD_ERASE;
                }
                else
                {
                    if (flash_sta == UPGRADE_FLASH_STATUS_SUCCESS)
                    {
                        download_fw_state = DOWNLOAD_FW_CHECK_PROGRESS;
                    }
                    else if (flash_sta == UPGRADE_FLASH_STATUS_BUSY)
                    {
                        // Check timer for timeout
                        if (SysTimer_IsTimeout(&timer_ms))
                            download_fw_state = DOWNLOAD_FW_FLASH_ERASE_RETRY;
                    }
                    else
                    {
                        // Error
                        download_fw_state = DOWNLOAD_FW_FLASH_ERASE_RETRY;
                    }
                }
                break;

            case DOWNLOAD_FW_FLASH_ERASE_RETRY:
                if (++ retry_count <= 8)
                    download_fw_state = DOWNLOAD_FW_FLASH_ERASE;
                else
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;

            case DOWNLOAD_FW_CHECK_PROGRESS:
                if (flash_write_offset < flash_total_size)
                    download_fw_state = DOWNLOAD_FW_READ_PACKAGE;
                else
                    download_fw_state = DOWNLOAD_FW_RESET;

                // Reset retry count
                retry_count = 0;
                break;

            case DOWNLOAD_FW_READ_PACKAGE:
            {
		        uint32_t reading_size, file_size;
                //uint32_t file_emb_crc, file_emb_signature;

		        uc15_sta = uc15_atcmd_readfile (on_enter, UPGRADE_FW_DOWNLOAD_FILENAME, flash_write_offset, flash_data_count*4, (uint8_t *)flash_data, &reading_size, &file_size);
                if (uc15_sta == UC15_OK)
                {
                   *flash_cmd = UPGRADE_FLASH_CMD_WRITE_FLASH;
                   *flash_offset = flash_write_offset;
                   download_fw_state = DOWNLOAD_FW_FLASH_WRITE;
                   retry_count = 0;
                }
                else if (uc15_sta == UC15_ERROR)
                    download_fw_state = DOWNLOAD_FW_ERROR;
				else if (uc15_sta != UC15_BUSY)
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;
            }

            case DOWNLOAD_FW_FLASH_WRITE:
                if (on_enter)
                {
                    SysTimer_Start (&timer_ms, 2000);
                }
                if (flash_sta == UPGRADE_FLASH_STATUS_SUCCESS)
                {
                    // Offset Increment
                    flash_write_offset += (flash_data_count*4);
                    download_fw_state = DOWNLOAD_FW_CHECK_PROGRESS;
                }
                else if (flash_sta == UPGRADE_FLASH_STATUS_BUSY)
                {
                    // Check timer for timeout
                    if (SysTimer_IsTimeout(&timer_ms))
                        download_fw_state = DOWNLOAD_FW_FLASH_WRITE_RETRY;
                }
                else
                {
                    // Error
                    download_fw_state = DOWNLOAD_FW_FLASH_WRITE_RETRY;
                } 
                break;

            case DOWNLOAD_FW_FLASH_WRITE_RETRY:
                if (++ retry_count <= 8)
                    download_fw_state = DOWNLOAD_FW_READ_PACKAGE;
                else
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;

            case DOWNLOAD_FW_RESET:
                if (on_enter)
                {
                    *flash_cmd = UPGRADE_FLASH_CMD_RESET;
                    SysTimer_Start (&timer_ms, 3000);
                }
                else
                {
                    if (flash_sta == UPGRADE_FLASH_STATUS_SUCCESS)
                    {
                        download_fw_state = DOWNLOAD_FW_RESET_WAIT;
                    }
                    else if (flash_sta == UPGRADE_FLASH_STATUS_BUSY)
                    {
                        // Check timer for timeout
                        if (SysTimer_IsTimeout(&timer_ms))
                            download_fw_state = DOWNLOAD_FW_RESET_RETRY;
                    }
                    else
                    {
                        // Error
                        download_fw_state = DOWNLOAD_FW_RESET_RETRY;
                    }                     
                }
                break;

            case DOWNLOAD_FW_RESET_RETRY:
                if (++ retry_count <= 5)
                    download_fw_state = DOWNLOAD_FW_RESET;
                else
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;

            case DOWNLOAD_FW_RESET_WAIT:
                if (on_enter)
                {
                    SysTimer_Start (&timer_ms, 5000);
                }
                if (SysTimer_IsTimeout(&timer_ms))
                {
                    retry_count = 0;
                    download_fw_state = DOWNLOAD_FW_VALIDATE;
                }
                break;

            case DOWNLOAD_FW_VALIDATE:
                if (on_enter)
                {
                    *flash_cmd = UPGRADE_FLASH_CMD_GET_MAINCRC;
                    SysTimer_Start(&timer_ms, 2000);
                }
                else
                {
                    if ((flash_sta == UPGRADE_FLASH_STATUS_BUSY) || (flash_sta == 0))
                    {
                        // Timeout check
                        if (SysTimer_IsTimeout(&timer_ms))
                            download_fw_state = DOWNLOAD_FW_VALIDATE_RETRY;
                    }
                    else if (flash_sta == setting_upgrade_fw_crc)
                    {
                        UC15_SetSystemMessage("Firmware upgrade: Success.");
                        download_fw_state = DOWNLOAD_FW_SUCCESS;
                    }
                    else
                    {
                        UC15_SetSystemMessage("Firmware upgrade: Error.");
                        download_fw_state = DOWNLOAD_FW_ERROR;
                    }
                }
                break;

            case DOWNLOAD_FW_VALIDATE_RETRY:
                if (++ retry_count <= 8)
                    download_fw_state = DOWNLOAD_FW_VALIDATE;
                else
                    download_fw_state = DOWNLOAD_FW_TIMEOUT;
                break;

            case DOWNLOAD_FW_UNLOCK:
               uc15_session_release (session);
               if (download_fw_status_error)
                   ret = STA_HTTP_ERROR;
               else if (download_fw_timeout)
                   ret = STA_HTTP_TIMEOUT;
               else
                   ret = STA_HTTP_SUCCESS;
               download_fw_state = DOWNLOAD_FW_SESSION_ACQUIRE; // Back
               break;

            case DOWNLOAD_FW_SUCCESS:
                download_fw_state = DOWNLOAD_FW_UNLOCK;
                break;

            case DOWNLOAD_FW_ERROR:
                download_fw_status_error = 1;
                download_fw_state = DOWNLOAD_FW_UNLOCK;
                break;

            case DOWNLOAD_FW_TIMEOUT:
                download_fw_timeout = 1;
                download_fw_state = DOWNLOAD_FW_UNLOCK;
                break;

            default:
                break;
        }

        return ret;
    }

    // --- get ---
    typedef enum
    {
      HTTP_GET_SESSION_ACQUIRE = 0,
      HTTP_GET_PROCESSING,

      HTTP_GET_UNLOCK,      

      HTTP_GET_SUCCESS,
      HTTP_GET_ERROR,
      HTTP_GET_TIMEOUT
      
    } HTTP_GET_STATE;

    STA_HTTP_STATUS aMG_Http_Get (uint8_t *session, const char *url, int32_t url_len, char *output, int32_t output_len, uint16_t *return_len)
    {
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static HTTP_GET_STATE http_get_state = HTTP_GET_SESSION_ACQUIRE;
        static HTTP_GET_STATE http_get_state_last = HTTP_GET_SESSION_ACQUIRE;

        static uint8_t http_get_status_error = 0;
        static uint8_t http_get_timeout = 0;
 
        STA_HTTP_STATUS tmp_sta;
        uint8_t on_enter;

        char tmp_buffer [1024];

        // Return len default 0
        *return_len = 0;

        if (http_get_state_last != http_get_state)
        {
            on_enter = 1;
            http_get_state_last = http_get_state;
        }
        else { on_enter = 0; }

        // State processing
        switch (http_get_state)
        {
            case HTTP_GET_SESSION_ACQUIRE:
                http_get_status_error = 0;
                http_get_timeout = 0;
                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    http_get_state = HTTP_GET_PROCESSING;
                }
                break;

            case HTTP_GET_PROCESSING:
                memcpy(tmp_buffer, url, url_len);
                tmp_buffer [url_len] = '\0';
                tmp_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_GET, 1, tmp_buffer, (char *)0, (char *)0, (char *)0, output, output_len);
	            if (tmp_sta == STA_HTTP_SUCCESS)
                    http_get_state = HTTP_GET_SUCCESS; // Success
	            else if (tmp_sta == STA_HTTP_ERROR)
                    http_get_state = HTTP_GET_ERROR;
	            else if (tmp_sta != STA_HTTP_BUSY)
                    http_get_state = HTTP_GET_TIMEOUT;
                break;

            case HTTP_GET_UNLOCK:
               uc15_session_release (session);
               if (http_get_status_error) {
                   ret = STA_HTTP_ERROR;
               }
               else if (http_get_timeout) {
                   ret = STA_HTTP_TIMEOUT;
               }
               else
               {
                   ret = STA_HTTP_SUCCESS;
                   *return_len = strlen (output);
               }
               http_get_state = HTTP_GET_SESSION_ACQUIRE; // Back
               break;

            case HTTP_GET_ERROR:
                http_get_status_error = 1;
                http_get_state = HTTP_GET_UNLOCK;         
                break;

            case HTTP_GET_TIMEOUT:
                http_get_timeout = 1;
                http_get_state = HTTP_GET_UNLOCK;
                break;

            case HTTP_GET_SUCCESS:
                http_get_state = HTTP_GET_UNLOCK;
                break;
        }
        return ret;
    }

    // --- post ---
    typedef enum
    {
      HTTP_POST_SESSION_ACQUIRE = 0,
      HTTP_POST_PROCESSING,

      HTTP_POST_UNLOCK,      

      HTTP_POST_SUCCESS,
      HTTP_POST_ERROR,
      HTTP_POST_TIMEOUT
      
    } HTTP_POST_STATE;

    STA_HTTP_STATUS aMG_Http_Post (uint8_t *session, const char *action, int32_t action_len, const char *body, int32_t body_len)
    {
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static HTTP_POST_STATE http_post_state = HTTP_POST_SESSION_ACQUIRE;
        static HTTP_POST_STATE http_post_state_last = HTTP_POST_SESSION_ACQUIRE;

        static uint8_t http_post_status_error = 0;
        static uint8_t http_post_timeout = 0;
 
        STA_HTTP_STATUS tmp_sta;
        uint8_t on_enter;

        char tmp_buffer [1024];

        if (http_post_state_last != http_post_state)
        {
            on_enter = 1;
            http_post_state_last = http_post_state;
        }
        else { on_enter = 0; }

        // State processing
        switch (http_post_state)
        {
            case HTTP_POST_SESSION_ACQUIRE:
                http_post_status_error = 0;
                http_post_timeout = 0;
                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    http_post_state = HTTP_POST_PROCESSING;
                }
                break;

            case HTTP_POST_PROCESSING:
                memcpy(app_proc_url, action, action_len);
                app_proc_url [action_len] = '\0';

                if (body_len < APP_PROC_DATA_SIZE) {
                  memcpy(app_proc_data, body, body_len);
                  app_proc_data [body_len] = '\0';
                  tmp_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_POST, 1, app_proc_url, (char *)app_proc_data, (char *)0, (char *)0, tmp_buffer, sizeof(tmp_buffer));
                }
                else {
                  tmp_sta = uc15_http_mothod (on_enter, HTTP_OPERATION_POST, 1, app_proc_url, (char *)body, (char *)0, (char *)0, tmp_buffer, sizeof(tmp_buffer));
                }
	            if (tmp_sta == STA_HTTP_SUCCESS)
                    http_post_state = HTTP_POST_SUCCESS; // Success
	            else if (tmp_sta == STA_HTTP_ERROR)
                    http_post_state = HTTP_POST_ERROR;
	            else if (tmp_sta != STA_HTTP_BUSY)
                    http_post_state = HTTP_POST_TIMEOUT;
                break;

            case HTTP_POST_UNLOCK:
               uc15_session_release (session);
               if (http_post_status_error) {
                   ret = STA_HTTP_ERROR;
               }
               else if (http_post_timeout) {
                   ret = STA_HTTP_TIMEOUT;
               }
               else
               {
                   ret = STA_HTTP_SUCCESS;
               }
               http_post_state = HTTP_POST_SESSION_ACQUIRE; // Back
               break;

            case HTTP_POST_ERROR:
                http_post_status_error = 1;
                http_post_state = HTTP_POST_UNLOCK;         
                break;

            case HTTP_POST_TIMEOUT:
                http_post_timeout = 1;
                http_post_state = HTTP_POST_UNLOCK;
                break;

            case HTTP_POST_SUCCESS:
                http_post_state = HTTP_POST_UNLOCK;
                break;
        }
        return ret;
    }

// --- getnetworktime ---
typedef enum {
  NETWORKTIME_SESSION_ACQUIRE = 0,
  NETWORKTIME_CONNECT,
  NETWORKTIME_CONTEXTID,
  NETWORKTIME_GET_NTP_ADDRESS,
  NETWORKTIME_GET_NTP_ADDRESS_LIST,
  NETWORKTIME_GET_NTP_PROCESS,
  NETWORKTIME_SESSION_UNLOCK,
  NETWORKTIME_SUCCESS,
  NETWORKTIME_ERROR,
  NETWORKTIME_TIMEOUT
} GET_NETWORKTIME_STATE;

STA_HTTP_STATUS aMG_Get_NetworkTime (uint8_t *session, uint8_t *datetime_7)
{
  static SYS_TIMER_STRUCT timer_ms = { 0, 0 };

	static int dnsgip_count = 0;
	static int dnsgip_index = 0;
	static int ip0 =0;
	static int ip1 = 0;
	static int ip2 = 0;
	static int ip3 = 0;
	
	static uint8_t get_ntp_error = 0;
	static uint8_t get_ntp_timeout = 0;
	
  static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
  static GET_NETWORKTIME_STATE get_networktime_state = NETWORKTIME_SESSION_ACQUIRE;
  static GET_NETWORKTIME_STATE get_networktime_state_last = NETWORKTIME_SESSION_ACQUIRE;
  UC15_STATUS sta;
  uint8_t on_enter;
  if (get_networktime_state_last != get_networktime_state) {
    on_enter = 1;
    get_networktime_state_last = get_networktime_state;
  } else {
    on_enter = 0;
  }

  switch (get_networktime_state) {
   case NETWORKTIME_SESSION_ACQUIRE:
    ret = STA_HTTP_BUSY;
    if (uc15_session_lock (session)) {
      get_networktime_state = NETWORKTIME_CONNECT;
			
	    get_ntp_error = 0;
	    get_ntp_timeout = 0;			
    }
    break;

   case NETWORKTIME_CONNECT:
    sta = uc15_module_connect (on_enter);
    if (sta == UC15_OK)
      get_networktime_state = NETWORKTIME_CONTEXTID;
    else if (sta == UC15_ERROR)
      get_networktime_state = NETWORKTIME_ERROR;
    else if (sta != UC15_BUSY)
      get_networktime_state = NETWORKTIME_TIMEOUT;
    break;

   case NETWORKTIME_CONTEXTID:
    sta = uc15_activate_context (on_enter, 1);
    if (sta == UC15_OK)
      get_networktime_state = NETWORKTIME_GET_NTP_ADDRESS;
    else if (sta != UC15_BUSY)
      get_networktime_state = NETWORKTIME_TIMEOUT;
    break;

   case NETWORKTIME_GET_NTP_ADDRESS:
	sprintf (uc15_proc_buffer, "AT+QIDNSGIP=1,\"%s\"", "0.th.pool.ntp.org");
    sta = uc15_atcmd_configure (on_enter, uc15_proc_buffer, "OK", 2000);
    if (sta == UC15_OK) {
	  get_networktime_state = NETWORKTIME_GET_NTP_ADDRESS_LIST;
	}
	else if (sta != UC15_BUSY)
    get_networktime_state = NETWORKTIME_TIMEOUT;
    break;
		
	 case NETWORKTIME_GET_NTP_ADDRESS_LIST:
		 if (on_enter) {
			 SysTimer_Start (&timer_ms,1000);
			 dnsgip_index = 0;
		 }
		 if (SysTimer_IsTimeout(&timer_ms)) {
			 // 0: Get count
			 if (dnsgip_index == 0) {
				 char *p;
				 sta = uc15_atcmd_query (1, "", "+QIURC:", 100, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				 while (sta == UC15_BUSY) {
					 sta = uc15_atcmd_query (0, "", "+QIURC:", 100, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				 }
				 if (sta == UC15_OK) {
					 dnsgip_index ++;
					 p = strstr(uc15_proc_buffer, "\"dnsgip\",");
					 if (p) {
						 int sta,ttl;
						 p+= strlen("\"dnsgip\",");
						 dnsgip_count = 0;
						 sscanf (p,"%d,%d,%d", &sta, &dnsgip_count, &ttl);
						 if (dnsgip_count > 0) {
							 // Next
						 }
						 else get_networktime_state = NETWORKTIME_ERROR;
					 }
					 else get_networktime_state = NETWORKTIME_ERROR;
				 }
				 else {
					 get_networktime_state = NETWORKTIME_TIMEOUT;
				 }
			 }
			 else if (dnsgip_index == 1) {
				 char *p;
				 sta = uc15_atcmd_query (1, "", "+QIURC:", 100, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				 while (sta == UC15_BUSY) {
					 sta = uc15_atcmd_query (0, "", "+QIURC:", 100, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				 }				 
				 if (sta == UC15_OK) {
					 dnsgip_index ++;
					 p = strstr(uc15_proc_buffer, "\"dnsgip\",\"");
					 if (p) {
						 
						 p+= strlen("\"dnsgip\",\"");
						 dnsgip_count = 0;
                         %assign tmp = "%"
						 if (sscanf (p,"%<tmp>d.%<tmp>d.%<tmp>d.%<tmp>d", &ip0, &ip1, &ip2, &ip3) == 4) {
						    // Valid address
							  get_networktime_state = NETWORKTIME_GET_NTP_PROCESS;
						 }
						 else get_networktime_state = NETWORKTIME_ERROR;
					 }
					 else get_networktime_state = NETWORKTIME_ERROR;
				 }
				 else {
					 get_networktime_state = NETWORKTIME_TIMEOUT;
				 }				 
			 }
			 else {
				 // Unexpected:
				 get_networktime_state = NETWORKTIME_ERROR;
			 }
		 }
		 break;

   case NETWORKTIME_GET_NTP_PROCESS:
         %assign tmp = "%"
		 sprintf (uc15_proc_buffer, "AT+QNTP=1,\"%<tmp>d.%<tmp>d.%<tmp>d.%<tmp>d\",123", ip0, ip1, ip2, ip3);
		 sta = uc15_atcmd_query (on_enter, uc15_proc_buffer, "+QNTP:", 30000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
	   if (sta == UC15_OK) {
             int day_count;
			 char *p;
			 int yyyy,mo,dd,hh,mm,ss,tz;
			 p = strstr(uc15_proc_buffer,"\"");
			 if (p) {
				 p++;
                 %assign tmp = "%"
				 if (sscanf(p,"%<tmp>d/%<tmp>d/%<tmp>d,%<tmp>d:%<tmp>d:%<tmp>d+%<tmp>d", &yyyy,&mo,&dd,&hh,&mm,&ss,&tz) == 7) {
					 int hour = hh+ 7;
					 if (hour >= 24) {
						 hour -= 24;

                         // Determine Max day of month
                         switch (mo) {
                           case 1: // Jan=31
                           case 3: // Mar=31
                           case 5: // May=31
                           case 8: // Aug=31
                           case 7: // July=31
                           case 10:// Oct=31
                           case 12:// Dec=31
                             day_count = 31;
                             break;

                           case 2: // Feb=28/29
                             %assign tmp = "%"
                             if ((yyyy %<tmp> 4)==0) day_count = 29;
                               else day_count = 28;
                             break;

                           case 4: // Apr=30
                           case 6: // Jun=30
                           case 9: // Sep=30
                           case 11:// Nov=30
                           default:
                             day_count = 30;
                             break;
                         }

                         // Day increment
                         dd ++;
                         if (dd > day_count) {
                           dd = 1;
                           mo++;
                         }
                         if (mo > 12) {
                           mo = 1;
                           yyyy++;
                         }
                     }
					 
					 datetime_7[0] = (uint8_t)(yyyy-2000);
					 datetime_7[1] = (uint8_t)mo;
					 datetime_7[2] = (uint8_t)dd;
					 datetime_7[3] = (uint8_t)hour;
					 datetime_7[4] = (uint8_t)mm;
					 datetime_7[5] = (uint8_t)ss;
					 datetime_7[6] = (uint8_t)tz;					 
					 
					 _uc15_set_datatime(datetime_7);
				 }
			 }
			 get_networktime_state = NETWORKTIME_SUCCESS;
		 }
		 else if (sta != UC15_BUSY) {
			 get_networktime_state = NETWORKTIME_TIMEOUT;
		 }
     break;

   case NETWORKTIME_SESSION_UNLOCK:
		 uc15_session_release (session);
	   if (get_ntp_error)
			 ret = STA_HTTP_ERROR;
		 else if (get_ntp_timeout)
			 ret = STA_HTTP_TIMEOUT;
		 else
			 ret = ret = STA_HTTP_SUCCESS;
		 get_networktime_state = NETWORKTIME_SESSION_ACQUIRE;
     break;

   case NETWORKTIME_SUCCESS:
		 get_networktime_state = NETWORKTIME_SESSION_UNLOCK;
     break;

   case NETWORKTIME_ERROR:
		 get_ntp_error = 1;
	   get_networktime_state = NETWORKTIME_SESSION_UNLOCK;
     break;

   case NETWORKTIME_TIMEOUT:
		 get_ntp_timeout = 1;
	   get_networktime_state = NETWORKTIME_SESSION_UNLOCK;		 
     break;

   default:
    break;
  }

  return ret;
}
    // --- sms ---
    typedef enum
    {
      SMS_SESSION_ACQUIRE = 0,
      
      SMS_CONF_TEXTMODE, // "AT+CMGF=1" for text mode
      SMS_CONF_CHARSET, // AT+CSCS="GSM"
      SMS_CHECK_RECEIPT_COUNT,
      SMS_NUMBER,
      SMS_BODY,
      SMS_WAIT_TIME, // Wait sometime before sendng another sms

      SMS_UNLOCK,      

      SMS_SUCCESS,
      SMS_ERROR,
      SMS_TIMEOUT
      
    } SMS_STATE;

    STA_HTTP_STATUS aMG_Sms_Send (uint8_t *session, const char *number, uint8_t max_count, int32_t number_len, const char *body, int32_t body_len, uint8_t *err_code, uint8_t *succ_cnt, uint8_t *err_cnt)
    {
        static SYS_TIMER_STRUCT timer_ms = {0, 0};
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static SMS_STATE sms_state = SMS_SESSION_ACQUIRE;
        static SMS_STATE sms_state_last = SMS_SESSION_ACQUIRE;

        static uint8_t sms_number_index = 0;
        static uint8_t sms_status_error = 0;
        static uint8_t sms_timeout = 0;

        static int sms_sending_error_count = 0;
        static int sms_sending_success_count = 0;
        static char receipt_number [32] = {0};
        static const char *pNext = (char *)0;
 
        STA_HTTP_STATUS tmp_sta;
        UC15_STATUS sta;
        uint8_t on_enter;

        char tmp_buffer [1024];

        if (sms_state_last != sms_state)
        {
            on_enter = 1;
            sms_state_last = sms_state;
        }
        else { on_enter = 0; }

        // State processing
        switch (sms_state)
        {
            case SMS_SESSION_ACQUIRE:
                sms_status_error = 0;
                sms_timeout = 0;
                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    uint8_t found;
                    int i,sms_num_len;
                    // Setup processing text
                    memcpy(app_proc_url, number, number_len);
                    app_proc_url [number_len] = '\0';
                    sms_num_len = strlen(app_proc_url);
                    found = 0;
                    i = 0;
                    while (!found && (i++ < sms_num_len)) {
                      if (app_proc_url[i] != ' ') {
                        found = 1;
                      }
                    }
                    sms_number_index = 0;
                    sms_sending_error_count = 0;
                    sms_sending_success_count = 0;
                    if (found) {
                      pNext = &app_proc_url [0];

                      sms_state = SMS_CONF_TEXTMODE;
                    }
                    else { 
                       sms_state = SMS_SUCCESS;
                    }
                }
                break;

            case SMS_CONF_TEXTMODE:
                sta = uc15_atcmd_configure (on_enter, "AT+CMGF=1", "OK", 1000);
                if (sta != UC15_BUSY)
                {
                    // Ignore failure status
                    sms_state = SMS_CONF_CHARSET;
                }
                break;

            case SMS_CONF_CHARSET:
                sta = uc15_atcmd_configure (on_enter, "AT+CSCS=\"GSM\"", "OK", 1000);
                if (sta != UC15_BUSY)
                {
                    // Ignore failure status
                    sms_state = SMS_CHECK_RECEIPT_COUNT;
                }
                break;                

            case SMS_CHECK_RECEIPT_COUNT:
            {
                uint32_t len;
                char *p;

                if (pNext && *pNext)
                {
                    p = strstr (pNext,",");
                    if (p)
                    {
                        len = p - pNext;
                        if ((len >= sizeof (receipt_number)) || (len < 10))
                        {
                            // Error
                            sms_sending_error_count ++;
                            pNext = ++p; 
                        }
                        else
                        {
                            memcpy(receipt_number, pNext, len);
                            receipt_number [len] = '\0';

                            pNext = ++p;
                            // Goto Send number
                            sms_state = SMS_NUMBER;
                        }
                    }
                    else
                    {
                        // Last or only one number to send
                        len = strlen(pNext);
                        memcpy(receipt_number, pNext, len);
                        receipt_number [len] = '\0';

                        pNext = &pNext[strlen(pNext)];
                        // Goto Send number
                        sms_state = SMS_NUMBER;
                    }

                    // Check exceed max count
                    if ((sms_number_index >= max_count) || (sms_number_index >= 8)) {
                        if (sms_state == SMS_NUMBER) {
                            sms_sending_error_count ++;
                        }
                        if (sms_number_index < 8){
                            err_code[sms_number_index] = 6; // Exceed
                            sms_number_index ++;
                        }
                        sms_state = SMS_CHECK_RECEIPT_COUNT;// Stay
                    }
                    else if (sms_state != SMS_NUMBER) {
                        if (sms_number_index < 8){
                            err_code[sms_number_index] = 5; //Invaid format
                            sms_number_index ++;
                        }                        
                    }
                }
                else
                {
                    // End of sending message
                    if (sms_sending_error_count > 0)
                        sms_state = SMS_ERROR;
                    else
                        sms_state = SMS_SUCCESS;
                }
                break;
            }

            case SMS_NUMBER:
                sprintf (tmp_buffer,"AT+CMGS=\"%s\"", receipt_number);
                sta = uc15_atcmd_configure (on_enter, tmp_buffer, ">", 1000);
                if (sta != UC15_BUSY)
                {
                    sms_state = SMS_BODY;
                }
                break;

            case SMS_BODY:
                memcpy (tmp_buffer, body, body_len);
                if (body_len > strlen(body))
                {
                    tmp_buffer [strlen(body)] = 0x1A;
                    tmp_buffer [strlen(body)+1] = 0;
                }
                else
                {
                    tmp_buffer [body_len] = 0x1A;
                    tmp_buffer [body_len+1] = 0;                    
                }

				sta = uc15_atcmd_query (on_enter, tmp_buffer, "+CMGS:", 8000, app_proc_url, sizeof(app_proc_url));
				if (sta == UC15_OK)
				{
					int32_t count, err;
					count = sscanf(app_proc_url, "+CMGS: %d", &err);
                    sms_sending_success_count ++;
                    sms_state = SMS_WAIT_TIME; //SMS_CHECK_RECEIPT_COUNT;

                    err_code[sms_number_index] = 0; //Success
                    sms_number_index ++;
				}
				else if (sta != UC15_BUSY)
				{
                    sms_sending_error_count ++;
                    sms_state = SMS_WAIT_TIME; //SMS_CHECK_RECEIPT_COUNT;

                    err_code[sms_number_index] = 7; //Error
                    sms_number_index ++;
				}
                break;

            case SMS_WAIT_TIME:
                if (on_enter) {
                    SysTimer_Start (&timer_ms, 3000);
                }
                if (SysTimer_IsTimeout(&timer_ms)) {
                    sms_state = SMS_CHECK_RECEIPT_COUNT;
                }

                break;

            case SMS_UNLOCK:
               uc15_session_release (session);
               if (sms_status_error) {
                   ret = STA_HTTP_ERROR;
               }
               else if (sms_timeout) {
                   ret = STA_HTTP_TIMEOUT;
               }
               else
               {
                   ret = STA_HTTP_SUCCESS;
               }
               sms_state = SMS_SESSION_ACQUIRE; // Back
               break;

            case SMS_ERROR:
                sms_status_error = 1;
                sms_state = SMS_UNLOCK;         
                break;

            case SMS_TIMEOUT:
                sms_timeout = 1;
                sms_state = SMS_UNLOCK;
                break;

            case SMS_SUCCESS:
                sms_state = SMS_UNLOCK;
                break;
        }

        // Update Count
        *err_cnt = (uint8_t)sms_sending_error_count;
        *succ_cnt = (uint8_t)sms_sending_success_count;

        // Return
        return ret;
    }

    // --- email ---
    typedef enum
    {
      EMAIL_SESSION_ACQUIRE = 0,
      EMAIL_STATE_CONNECT,
	  // --- Http config ---
      EMAIL_STATE_CONTEXT_DEACT,

	  EMAIL_STATE_CONTEXTID,
	  EMAIL_STATE_CONTEXT_STATE, // ?

	  EMAIL_STATE_CONTEXT_CONFIGURE,
	  EMAIL_STATE_CONTEXT_ACTIVATE,

	  // --- SSL ---
      EMAIL_STATE_SSLTYPE,
	  EMAIL_STATE_SSLID,
	  EMAIL_STATE_SSL_VERSION,
	  EMAIL_STATE_SSL_CIPHERSUITE,
	  EMAIL_STATE_SSL_SECURELEVEL,
      // --- SMTP ---
      EMAIL_STATE_CONF_SERVER,
      EMAIL_STATE_CONF_ACCOUNT,
      EMAIL_STATE_SENDER,

      EMAIL_STATE_INIT_RECEIPT_TO,
      EMAIL_STATE_SET_RECEIPT_TO,
      EMAIL_STATE_NEXT_RECEIPT_TO,

      EMAIL_STATE_INIT_RECEIPT_CC,
      EMAIL_STATE_SET_RECEIPT_CC,
      EMAIL_STATE_NEXT_RECEIPT_CC,

      EMAIL_STATE_SET_SUBJECT,
      EMAIL_STATE_SET_BODY_LEN,
      EMAIL_STATE_SET_BODY,
      EMAIL_STATE_SEND,

      EMAIL_STATE_CLEARALL,
      EMAIL_STATE_DEAT_FINAL,
      EMAIL_UNLOCK,    

      EMAIL_SUCCESS,
      EMAIL_ERROR,
      EMAIL_TIMEOUT
      
    } EMAIL_STATE;

    void aMG_EMail_ExtractName (const char *buffer, int32_t buffer_len, char *name)
    {
        uint32_t len, i;
        const char *p;
        const char *q;

        p = buffer;
        q = &buffer [buffer_len];
        i = 0;
        while ((i < buffer_len) && (buffer[i] != ':'))
            i++;
        if (i < buffer_len)
            q = &buffer [i];

        len = q-p;
        memcpy (name, p, len);
        name [len] = '\0';
    }

    void aMG_Email_ExtractEmail (const char *buffer, int32_t buffer_len, char *email)
    {
        uint32_t len, i;
        const char *p;
        const char *q;

        p = buffer;
        q = &buffer [buffer_len];
        i = 0;
        while ((i < buffer_len) && (buffer[i] != ':'))
            i++;
        if (i < buffer_len)
        {
            p = &buffer [i];
            p++;
        }

        len = q-p;
        memcpy (email, p, len);
        email [len] = '\0';
    }

    STA_HTTP_STATUS aMG_Email_Send (uint8_t *session, 
       const char *server, int32_t server_len, 
       uint32_t port,
       const char *user, int32_t user_len,
       const char *pass, int32_t pass_len,
       const char *sender, int32_t sender_len,
       const char *to, int32_t to_len,
       const char *cc, int32_t cc_len,
       const char *subject, int32_t subject_len,
       const char *body, int32_t body_len)
    {
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static EMAIL_STATE email_state = EMAIL_SESSION_ACQUIRE;
        static EMAIL_STATE email_state_last = EMAIL_SESSION_ACQUIRE;

        static uint8_t email_status_error = 0;
        static uint8_t email_timeout = 0;

        static int email_sending_error_count = 0;
        static char receipt_number [32] = {0};
        static const char *pNext = (char *)0;

        static uint8_t deact_state = 0; // DEACT state
        static uint8_t email_receipt_to_index = 0;
 
        //STA_HTTP_STATUS tmp_sta;
        UC15_STATUS sta;
        uint8_t on_enter;

        char tmp_buffer [1024];

        if (email_state_last != email_state)
        {
            on_enter = 1;
            email_state_last = email_state;
        }
        else { on_enter = 0; }

        // State processing
        switch (email_state)
        {
            case EMAIL_SESSION_ACQUIRE:
                email_status_error = 0;
                email_timeout = 0;
                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    deact_state = 0;
                    email_state = EMAIL_STATE_CONNECT;
                }
                break;

			case EMAIL_STATE_CONNECT:
				sta = uc15_module_connect (on_enter);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_CONTEXT_STATE;
                else if (sta == UC15_ERROR)
                    email_state = EMAIL_ERROR;                
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;

			case EMAIL_STATE_CONTEXT_STATE:
				sta = uc15_atcmd_query (on_enter, "AT+QIACT?", "+QIACT:", 2000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK)
				{
					int32_t context_id,context_state,context_type,ip1,ip2,ip3,ip4;
					
					if (sscanf(uc15_proc_buffer, "+QIACT: %d,%d,%d,\"%d.%d.%d.%d\"", 
						&context_id, &context_state,&context_type,&ip1,&ip2,&ip3,&ip4) >= 2)
					{
						// Store current IP address
						UC15_Module_Info.ip_address [0] = (uint8_t)ip1;
						UC15_Module_Info.ip_address [1] = (uint8_t)ip2;
						UC15_Module_Info.ip_address [2] = (uint8_t)ip3;
						UC15_Module_Info.ip_address [3] = (uint8_t)ip4;
							
                        if (!deact_state) // IP setting is from another process, deact first
                            email_state = EMAIL_STATE_CONTEXT_DEACT;
                        else
						    email_state = EMAIL_STATE_CONTEXTID;
					}
					else
					{
						email_state = EMAIL_TIMEOUT;
					}
				}
				else if (sta == UC15_TIMEOUT)
				{
                    deact_state = 1;
					email_state = EMAIL_STATE_CONTEXTID;
				}
				break;

            // --- deact ---
            case EMAIL_STATE_CONTEXT_DEACT:
				sta = uc15_atcmd_configure (on_enter, "AT+QIDEACT=1", "OK", 20000);
				if (sta == UC15_OK){
					email_state = EMAIL_STATE_CONTEXT_CONFIGURE;
                    deact_state = 1;
                }
				else if (sta != UC15_BUSY)
                {
					email_state = EMAIL_TIMEOUT;
                }
				break;

			// --- Http config ---
			case EMAIL_STATE_CONTEXT_CONFIGURE:
				sprintf((char *)tmp_buffer,"AT+QICSGP=1,1,\"%s\",\"%s\",\"%s\",1", \
					UC15_Module_Setting.Apn, UC15_Module_Setting.User, UC15_Module_Setting.Pass);			

				sta = uc15_atcmd_configure (on_enter, tmp_buffer, "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_CONTEXT_ACTIVATE;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;
			
			case EMAIL_STATE_CONTEXT_ACTIVATE:
				// AT+QIACT=1
				sta = uc15_atcmd_configure (on_enter, "AT+QIACT=1", "OK", 20000); // Timeout 20s
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_CONTEXT_STATE;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;

			case EMAIL_STATE_CONTEXTID:
				sta = uc15_atcmd_configure (on_enter, "AT+QHTTPCFG=\"contextid\",1", "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_SSLTYPE;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;
			
			// --- SSL ---
            case EMAIL_STATE_SSLTYPE:
				sta = uc15_atcmd_configure (on_enter, "AT+QSMTPCFG=\"ssltype\",1", "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_SSLID;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;

			case EMAIL_STATE_SSLID:
				// AT+QHTTPCFG="sslctxid",1
				sta = uc15_atcmd_configure (on_enter, "AT+QSMTPCFG=\"sslctxid\",1", "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_SSL_VERSION;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;
				
			case EMAIL_STATE_SSL_VERSION:
				// AT+QSSLCFG="sslversion",1,1
				sta = uc15_atcmd_configure (on_enter, "AT+QSSLCFG=\"sslversion\",1,1", "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_SSL_CIPHERSUITE;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;
			
			case EMAIL_STATE_SSL_CIPHERSUITE:
				sta = uc15_atcmd_configure (on_enter, "AT+QSSLCFG=\"ciphersuite\",1,0xffff", "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_SSL_SECURELEVEL;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;
			
			case EMAIL_STATE_SSL_SECURELEVEL:
				sta = uc15_atcmd_configure (on_enter, "AT+QSSLCFG=\"seclevel\",1,0", "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_CONF_SERVER;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
				break;

            case EMAIL_STATE_CONF_SERVER:
                if (on_enter)
                {
                    memcpy (tmp_buffer, server, server_len);
                    tmp_buffer [server_len] = '\0';
                    sprintf (uc15_proc_buffer, "AT+QSMTPCFG=\"smtpserver\",\"%s\",%u", tmp_buffer, port);
                }
                else
                    uc15_proc_buffer[0] = '\0';
				sta = uc15_atcmd_configure (on_enter, uc15_proc_buffer, "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_CONF_ACCOUNT;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;                
                break;

            case EMAIL_STATE_CONF_ACCOUNT:
                if (on_enter)
                {
                    char *s;
                    strcpy (uc15_proc_buffer, "AT+QSMTPCFG=\"account\",\"");
                    s = &uc15_proc_buffer[strlen(uc15_proc_buffer)];
                    memcpy (s,user, user_len);
                    s[user_len] = '\0';
                    s = &uc15_proc_buffer[strlen(uc15_proc_buffer)];
                    strcpy(s,"\",\"");
                    s = &uc15_proc_buffer[strlen(uc15_proc_buffer)];
                    memcpy (s, pass, pass_len);
                    s[pass_len] = '\0';
                    s = &uc15_proc_buffer[strlen(uc15_proc_buffer)];
                    strcpy(s,"\"");
                }
                else
                    uc15_proc_buffer[0] = '\0';
				sta = uc15_atcmd_configure (on_enter, uc15_proc_buffer, "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_SENDER;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
                break;

            case EMAIL_STATE_SENDER:
            {
                char *p_name, *p_email;
                p_name = &tmp_buffer[0];
                p_email = &tmp_buffer[sizeof(tmp_buffer)/2];

                aMG_EMail_ExtractName (sender, sender_len, p_name);
                aMG_Email_ExtractEmail (sender, sender_len, p_email);

                sprintf (uc15_proc_buffer,"AT+QSMTPCFG=\"sender\",\"%s\",\"%s\"", p_name, p_email);
				sta = uc15_atcmd_configure (on_enter, uc15_proc_buffer, "OK", 2000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_INIT_RECEIPT_TO;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
                break;
            }

            case EMAIL_STATE_INIT_RECEIPT_TO:
                memcpy(uc15_proc_buffer, to, to_len);
                uc15_proc_buffer [to_len] = '\0';
                email_receipt_to_index = 1;
                email_state = EMAIL_STATE_SET_RECEIPT_TO;
                break;

            case EMAIL_STATE_SET_RECEIPT_TO:
                if (on_enter)
                {
                    char *p, *q;
                    int32_t i, j, len;

                    p = &uc15_proc_buffer [0];
                    q = strstr (p, ",");
                    if (*p)
                    {
                        if (q)
                        {
                            len = q-p;
                            memcpy(app_proc_data, p, len);
                            app_proc_data [len] = '\0';

                            // roll buffer
                            q++;
                            while (*q)
                                *p++ = *q++;
                            *p = '\0';
                        }
                        else
                        {
                            // Last items
                            strcpy (app_proc_data, p);
                            *p = '\0';
                        }
                    }
                    else
                    {
                        // All done, next state
                        email_state = EMAIL_STATE_INIT_RECEIPT_CC;
                        app_proc_data [0] = '\0';
                    }
                }
                if (app_proc_data[0])
                {
                    char *p_name, *p_email;
                    p_name = &tmp_buffer[0];
                    p_email = &tmp_buffer[sizeof(tmp_buffer)/2];

                    aMG_EMail_ExtractName (app_proc_data, sender_len, p_name);
                    aMG_Email_ExtractEmail (app_proc_data, sender_len, p_email);

                    sprintf (tmp_buffer, "AT+QSMTPDST=1,1,\"%s\"", p_email); // Add TO
				    sta = uc15_atcmd_configure (on_enter, tmp_buffer, "OK", 2000);
				    if (sta == UC15_OK) {
                        email_receipt_to_index ++; // Increment receipt index
					    email_state = EMAIL_STATE_NEXT_RECEIPT_TO;
                    }
				    else if (sta != UC15_BUSY)
					    email_state = EMAIL_TIMEOUT;                    
                }
                else
                {
                    // Un-expected
                    if (email_state == EMAIL_STATE_SET_RECEIPT_TO)
                        email_state = EMAIL_ERROR;
                }
                break;

            case EMAIL_STATE_NEXT_RECEIPT_TO:
                email_state = EMAIL_STATE_SET_RECEIPT_TO;
                break;

            case EMAIL_STATE_INIT_RECEIPT_CC:
                memcpy(uc15_proc_buffer, cc, cc_len);
                uc15_proc_buffer [to_len] = '\0';
                email_state = EMAIL_STATE_SET_RECEIPT_CC;
                break;

            case EMAIL_STATE_SET_RECEIPT_CC:
                if (on_enter)
                {
                    char *p, *q;
                    int32_t i, j, len;

                    p = &uc15_proc_buffer [0];
                    q = strstr (p, ",");
                    if (*p)
                    {
                        if (q)
                        {
                            len = q-p;
                            memcpy(app_proc_data, p, len);
                            app_proc_data [len] = '\0';

                            // roll buffer
                            q++;
                            while (*q)
                                *p++ = *q++;
                            *p = '\0';
                        }
                        else
                        {
                            // Last items
                            strcpy (app_proc_data, p);
                            *p = '\0';
                        }
                    }
                    else
                    {
                        // All done, next state
                        email_state = EMAIL_STATE_SET_SUBJECT;
                        app_proc_data [0] = '\0';
                    }
                }
                if (app_proc_data[0])
                {
                    char *p_name, *p_email;
                    p_name = &tmp_buffer[0];
                    p_email = &tmp_buffer[sizeof(tmp_buffer)/2];

                    aMG_EMail_ExtractName (app_proc_data, sender_len, p_name);
                    aMG_Email_ExtractEmail (app_proc_data, sender_len, p_email);

                    sprintf (tmp_buffer, "AT+QSMTPDST=1,2,\"%s\"", p_email); // Add TO
				    sta = uc15_atcmd_configure (on_enter, tmp_buffer, "OK", 2000);
				    if (sta == UC15_OK) {
                        email_receipt_to_index ++; // Increment receipt index
					    email_state = EMAIL_STATE_NEXT_RECEIPT_CC;
                    }
				    else if (sta != UC15_BUSY)
					    email_state = EMAIL_TIMEOUT;                    
                }
                else
                {
                    // Un-expected
                    if (email_state == EMAIL_STATE_SET_RECEIPT_CC)
                        email_state = EMAIL_ERROR;
                }
                break;

            case EMAIL_STATE_NEXT_RECEIPT_CC:
                email_state = EMAIL_STATE_SET_RECEIPT_CC;
                break;

            case EMAIL_STATE_SET_SUBJECT:
                if (on_enter)
                {
                    memcpy (tmp_buffer, subject, subject_len);
                    tmp_buffer [subject_len] = '\0';
                    sprintf(uc15_proc_buffer, "AT+QSMTPSUB=0,\"%s\"",tmp_buffer);
                }
                else
                    uc15_proc_buffer[0] = '\0';

	            sta = uc15_atcmd_configure (on_enter, uc15_proc_buffer, "OK", 2000);
				if (sta == UC15_OK) {
				    email_state = EMAIL_STATE_SET_BODY_LEN;
                }
				else if (sta != UC15_BUSY)
				    email_state = EMAIL_TIMEOUT;                
                break;

            case EMAIL_STATE_SET_BODY_LEN:
                if (on_enter)
                {
                    memcpy (tmp_buffer, subject, subject_len);
                    tmp_buffer [subject_len] = '\0';
                    sprintf(uc15_proc_buffer, "AT+QSMTPBODY=0,%d,120",strlen(tmp_buffer));
                }
                else
                    uc15_proc_buffer[0] = '\0';
				sta = uc15_atcmd_configure (on_enter, uc15_proc_buffer, "CONNECT", 60000);
				if (sta == UC15_OK)
					email_state = EMAIL_STATE_SET_BODY;
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
                break;

            case EMAIL_STATE_SET_BODY:
                if (on_enter)
                {
                    memcpy (uc15_proc_buffer, subject, subject_len);
                    uc15_proc_buffer [subject_len] = '\0';
                }
                else
                    uc15_proc_buffer[0] = '\0';
	            sta = uc15_atcmd_configure (on_enter, uc15_proc_buffer, "OK", 2000);
				if (sta == UC15_OK) {
				    email_state = EMAIL_STATE_SEND;
                }
				else if (sta != UC15_BUSY)
				    email_state = EMAIL_TIMEOUT;  
                break;

            case EMAIL_STATE_SEND:
                strcpy (tmp_buffer, "AT+QSMTPPUT=300");
				sta = uc15_atcmd_query (on_enter, tmp_buffer, "+QSMTPPUT:", 60000, uc15_proc_buffer, UC15_PROC_BUFFER_SIZE);
				if (sta == UC15_OK)
				{
					int32_t count, err, http_code;
					count = sscanf(uc15_proc_buffer, "+QSMTPPUT: %d,%d", &err, &http_code);
					if ((count >= 1) && (err == 0))
						email_state = EMAIL_SUCCESS;
					else
						email_state = EMAIL_ERROR;
				}
				else if (sta != UC15_BUSY)
					email_state = EMAIL_TIMEOUT;
                break;

            case EMAIL_UNLOCK:
                uc15_session_release (session);
                if (email_status_error) {
                    ret = STA_HTTP_ERROR;
                }
                else if (email_timeout) {
                    ret = STA_HTTP_TIMEOUT;
                }
                else
                {
                    ret = STA_HTTP_SUCCESS;
                }
                email_state = EMAIL_SESSION_ACQUIRE; // Back
                break;

            case EMAIL_STATE_CLEARALL:
                // AT+QSMTPCLR
	            sta = uc15_atcmd_configure (on_enter, "AT+QSMTPCLR", "OK", 2000);
				if (sta != UC15_BUSY)
                {
				    email_state = EMAIL_STATE_DEAT_FINAL;
                }
                break;

            case EMAIL_STATE_DEAT_FINAL:
				sta = uc15_atcmd_configure (on_enter, "AT+QIDEACT=1", "OK", 5000);
				if (sta != UC15_BUSY)
                {
				    email_state = EMAIL_UNLOCK;
                }
                break;

            case EMAIL_ERROR:
                email_status_error = 1;
                email_state = EMAIL_STATE_CLEARALL;         
                break;

            case EMAIL_TIMEOUT:
                email_timeout = 1;
                email_state = EMAIL_STATE_CLEARALL;
                break;

            case EMAIL_SUCCESS:
                email_state = EMAIL_STATE_CLEARALL;
                break;
        }
        return ret;
    }

    %% --- systemconf ---
    typedef enum
    {
      SYSTEMCONF_SESSION_ACQUIRE = 0,
      SYSTEMCONF_SYNC_SETTING, // Downlaod setting to file
      SYSTEMCONF_READ_FILE, // Read setting from file

      SYSTEMCONF_UNLOCK,      

      SYSTEMCONF_SUCCESS,
      SYSTEMCONF_ERROR,
      SYSTEMCONF_TIMEOUT
    } SYSTEMCONF_STATE;

    STA_HTTP_STATUS aMG_Get_System_Conf (uint8_t *session, uint32_t *antid, char *remoteid, uint16_t remoteid_len)
    {
        static STA_HTTP_STATUS ret = STA_HTTP_BUSY;
        static SYSTEMCONF_STATE systemconf_state = SYSTEMCONF_SESSION_ACQUIRE;
        static SYSTEMCONF_STATE systemconf_state_last = SYSTEMCONF_SESSION_ACQUIRE;

        static uint8_t systemconf_status_error = 0;
        static uint8_t systemconf_timeout = 0;
 
        STA_HTTP_STATUS tmp_sta;
        UC15_STATUS uc15_sta;
        uint8_t on_enter;

        char tmp_buffer [1024];

        // default
        *antid = UC15_Module_Info.ant_id;

        if (systemconf_state_last != systemconf_state)
        {
            on_enter = 1;
            systemconf_state_last = systemconf_state;
        }
        else { on_enter = 0; }

        // State processing
        switch (systemconf_state)
        {
            case SYSTEMCONF_SESSION_ACQUIRE:
                systemconf_status_error = 0;
                systemconf_timeout = 0;
                ret = STA_HTTP_BUSY;
                if (uc15_session_lock (session))
                {
                    systemconf_state = SYSTEMCONF_SYNC_SETTING;
                }
                break;

            case SYSTEMCONF_SYNC_SETTING:
                tmp_sta = aMG_Sync_Master_Setting();
                if (tmp_sta == STA_HTTP_SUCCESS)
                    systemconf_state = SYSTEMCONF_READ_FILE;
                else if (tmp_sta == STA_HTTP_ERROR)
                    systemconf_state = SYSTEMCONF_ERROR;
                else if (tmp_sta != STA_HTTP_BUSY)
                    systemconf_state = SYSTEMCONF_TIMEOUT;
                break;

            case SYSTEMCONF_READ_FILE:
                uc15_sta = uc15_atcmd_readtextfile (on_enter, MASTER_SETTING_DOWNLOAD_FILENAME, 0, UC15_PROC_BUFFER_SIZE, uc15_proc_buffer);
                if (uc15_sta == UC15_OK)
                {
                    int len;
                    char *p,*q;
                    const char *REMOTE_ANT_ID = "REMOTE_ANT_ID:";
                    const char *REMOTE_ID = "REMOTE_ID:";

                    // --- Remote ANT ID ---
                    p = strstr (uc15_proc_buffer, REMOTE_ANT_ID);
                    if (p)
                    {
                        uint32_t tmp_ant_id = 0;
                        
                        p += strlen (REMOTE_ANT_ID);
                        if ((sscanf (p, "%u", &tmp_ant_id) == 1) && (tmp_ant_id > 0) && (tmp_ant_id < 255))
                        {
                            // Return ANT ID with key
                            *antid = (0xAA550000 | tmp_ant_id);
                            
                            if (UC15_Module_Info.ant_id != *antid)
                            {
                                UC15_Module_Info.ant_id = *antid;
                                sprintf (tmp_buffer, "Update remote ANT ID: %u", tmp_ant_id);
                                UC15_SetSystemMessage (tmp_buffer);
                            }

                            // Success
                            systemconf_state = SYSTEMCONF_SUCCESS;
                        }
                        else
                        {
                            // Invalid ANT id
                            systemconf_state = SYSTEMCONF_ERROR;
                        }
                    }
                    else
                    {
                        // Remote ANT ID configuration not available
                        systemconf_state = SYSTEMCONF_ERROR;
                    }

                    // --- Remote ID ---
                    p = strstr (uc15_proc_buffer, REMOTE_ID);
                    if (p)
                    {
                        uint32_t tmp_ant_id = 0;
                        
                        p += strlen (REMOTE_ID);
                        strncpy (remoteid, p, remoteid_len);
                        remoteid[remoteid_len-1] = '0';
                        p = strstr(remoteid, "\\");
                        if (p) *p = '\0';

                        // Success
                        systemconf_state = SYSTEMCONF_SUCCESS;
                    }
                    else
                    {
                        // Remote ANT ID configuration not available
                        systemconf_state = SYSTEMCONF_ERROR;
                    }                    
                }
                else if (uc15_sta == UC15_ERROR)
                {
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 1;
                    systemconf_state = SYSTEMCONF_ERROR;
                }
                else if (uc15_sta != UC15_BUSY)
                {
                    UC15_Module_Pwrcmd.Requst_Sync_Setting = 1;
                    systemconf_state = SYSTEMCONF_TIMEOUT;
                }
                break;

            case SYSTEMCONF_UNLOCK:
               uc15_session_release (session);
               if (systemconf_status_error)
                   ret = STA_HTTP_ERROR;
               else if (systemconf_timeout)
                   ret = STA_HTTP_TIMEOUT;
               else
                   ret = STA_HTTP_SUCCESS;
               systemconf_state = SYSTEMCONF_SESSION_ACQUIRE; // Back
               break;

            case SYSTEMCONF_ERROR:
                systemconf_status_error = 1;
                systemconf_state = SYSTEMCONF_UNLOCK;         
                break;

            case SYSTEMCONF_TIMEOUT:
                systemconf_timeout = 1;
                systemconf_state = SYSTEMCONF_UNLOCK;
                break;

            case SYSTEMCONF_SUCCESS:
                systemconf_state = SYSTEMCONF_UNLOCK;
                break;
        }
        return ret;        
    }
%endif

 %% --- upload_data ---
%if conf == "upload_data"

static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t %<blockid>_Upload_Data(uint8_t trig, const uint8_t *data, uint16_t data_len)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
			int i;
			char *p;
			uint32_t value;
			uint32_t dd,mo,yy,hh,mm,ss;
			
			// --- DATA ---
			// DATA:%X,%X,%X,%X,%X,%1.2f,%1.2f,%1.2f,%1.2f,%1.2f,%1.2f,%1.2f,%1.2f,%1.2f,%1.2f,%1.2f,%1.2f,%X
			// 0 - uint32, output on/off status, bit0=output1, bit1=output2,...,bit31=output32
			// 1 - uint32, date, dd=value/10000, mo=(value-dd*10000)/100, yy=value-dd*10000-mo*100
			// 2 - uint32, time, hh=value/10000, mm=(value-hh*10000)/100, ss=value-hh*10000-mm*100
			// 3 - uint32, selector 1-16, select1=bit[1:0], selector2=bit[3:2],...,selector16=bit[31:30]
			// 4 - uint32, selector 17-32, select1=bit[1:0], selector2=bit[3:2],...,selector16=bit[31:30]
			// 5 - float, Lux
			// 6,7,8,9,10,11 - float, soil#1-soil#6
			// 12 - float, Humid
			// 13 - float, Temp
			// 14 - float, reserved
			// 15 - float, reserved
			// 16 - float, MCU temp
			// 17 - uint32, controller_fw_crc
			// 18 - float, WaterLevel
			
			// output
			p = string_follow_with ((char *)data, "DATA:");
			if (p) sscanf (p,"%X",&(aMG_Post_Data_Struct.output));
			// date
			p = string_follow_with (p, ",");
			if (p) {
				sscanf (p,"%X",&value);
				dd = (uint32_t)(value/10000);
				mo = (uint32_t)(value-dd*10000)/100;
				yy = (uint32_t)(value-dd*10000-mo*100);
				aMG_Post_Data_Struct.date[0] = (uint8_t)dd;
				aMG_Post_Data_Struct.date[1] = (uint8_t)mo;
				aMG_Post_Data_Struct.date[2] = (uint8_t)yy;
				//
				aMG_Post_Data_Struct.date_value = value;
			}
			// time
			p = string_follow_with (p, ",");
			if (p) {
				sscanf (p,"%X",&value);
				hh = (uint32_t)(value/10000);
				mm = (uint32_t)(value-hh*10000)/100;
				ss = (uint32_t)(value-hh*10000-mm*100);
				aMG_Post_Data_Struct.time[0] = (uint8_t)hh;
				aMG_Post_Data_Struct.time[1] = (uint8_t)mm;
				aMG_Post_Data_Struct.time[2] = (uint8_t)ss;
				//
				aMG_Post_Data_Struct.time_value = value;
			}			
			// selector 1-16
			p = string_follow_with (p, ",");
			if (p) {
				sscanf (p,"%X",&value);			
				for (i=0; i<16; i++)
					aMG_Post_Data_Struct.selector[i] = (uint8_t)(((uint32_t)value >> (i*2)) & 3);
			}
			// selector 17-32
			p = string_follow_with (p, ",");
			if (p) {
				sscanf (p,"%X",&value);			
				for (i=0; i<16; i++)
					aMG_Post_Data_Struct.selector[i+16] = (uint8_t)(((uint32_t)value >> (i*2)) & 3);
			}
			// lux
			p = string_follow_with (p, ",");
			if (p) {
				sscanf (p,"%f",&(aMG_Post_Data_Struct.lux));
			}
			// soil
			for (i=0; i<6;i++) {
				if (p) {
					p = string_follow_with (p, ",");
					sscanf (p,"%f",&(aMG_Post_Data_Struct.soil[i]));
				}
			}
			// humid
			p = string_follow_with (p, ",");
			if (p) sscanf (p,"%f",&(aMG_Post_Data_Struct.humid));
			// temp
			p = string_follow_with (p, ",");
			if (p) sscanf (p,"%f",&(aMG_Post_Data_Struct.temp));
			// rsvd1
			p = string_follow_with (p, ",");
			if (p) sscanf (p,"%f",&(aMG_Post_Data_Struct.rsvd1));
			// rsvd2
			p = string_follow_with (p, ",");
			if (p) sscanf (p,"%f",&(aMG_Post_Data_Struct.rsvd2));		
			// mcutemp
			p = string_follow_with (p, ",");
			if (p) sscanf (p,"%f",&(aMG_Post_Data_Struct.mcutemp));	
			// fw
			p = string_follow_with (p, ",");
			if (p) sscanf (p,"%X",&(aMG_Post_Data_Struct.fw));
			// WaterLeve
			p = string_follow_with (p, ",");
			if (p) sscanf (p,"%f",&(aMG_Post_Data_Struct.waterlevel));
		    // Magnetic
		    p = string_follow_with (p, ",");
		    if (p) sscanf (p,"%u",&(aMG_Post_Data_Struct.magnetic));
		    // Debug1
		    p = string_follow_with (p, ",");
		    if (p) sscanf (p,"%u",&(aMG_Post_Data_Struct.debug1));					
		    // Debug2
		    p = string_follow_with (p, ",");
		    if (p) sscanf (p,"%u",&(aMG_Post_Data_Struct.debug2));					
		    // Debug3
		    p = string_follow_with (p, ",");
		    if (p) sscanf (p,"%u",&(aMG_Post_Data_Struct.debug3));			
		    // Debug4
		    p = string_follow_with (p, ",");
		    if (p) sscanf (p,"%u",&(aMG_Post_Data_Struct.debug4));					
		    // Debug5
	      	p = string_follow_with (p, ",");
		    if (p) sscanf (p,"%u",&(aMG_Post_Data_Struct.debug5));
            // Wireless Data

            // 'wb1','wb2','wb3','wb4','wb5',
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wb[0])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wb[1])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wb[2])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wb[3])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wb[4])); }

            // 'wh1','wh2','wh3','wh4','wh5',
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wh[0])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wh[1])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wh[2])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wh[3])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wh[4])); }

            // 'wt1','wt2','wt3','wt4','wt5',
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wt[0])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wt[1])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wt[2])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wt[3])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.wt[4])); }
			
            // 'ws1','ws2','ws3','ws4','ws5',
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.ws[0])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.ws[1])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.ws[2])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.ws[3])); }
            p = string_follow_with (p, ",");
            if (p) { sscanf(p, "%f", &(aMG_Post_Data_Struct.ws[4])); }

			//iso-time-format
			sprintf (aMG_Post_Data_Struct.isotime,"%d-%2d-%2dT%2d:%2d:%2d+07:00",(2000+yy),mo,dd,hh,mm,ss);
			p = aMG_Post_Data_Struct.isotime;
			while (*p) {
				if (*p == ' ') *p = '0';
				p++;
			}

            process_trigged = 1;

            // Change status to busy
            sta = STA_HTTP_BUSY;
       }
      else
       {
           sta = STA_HTTP_IDLE;
       }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Upload_Data (&%<blockid>_Session, 0/*Data*/, 0/*Channel*/,(char *)0);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;

            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 5) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- upload_setting_version ---
%if conf == "upload_setting_version"
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t %<blockid>_Upload_Setting_Version(uint8_t trig, const uint32_t *version)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;
    char Tmp_Setting[512] = {0};

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {            
            process_trigged = 1;

            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        int i;
        Tmp_Setting[0] = '\0';
        sprintf(&Tmp_Setting[strlen(Tmp_Setting)],"version=");
        for (i=0; i<32; i++) {
            if (i > 0)
              sprintf(&Tmp_Setting[strlen(Tmp_Setting)],",");
            sprintf(&Tmp_Setting[strlen(Tmp_Setting)],"%u", version[i]);
        }
        sta = aMG_Upload_Data (&%<blockid>_Session, 3/*Setting Version*/, 0/*Channel*/, Tmp_Setting);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;
            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 5) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- upload_setting ---
%if conf == "upload_setting"
static char %<blockid>_Setting[1024] = {0};
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t %<blockid>_Upload_Setting(uint8_t trig, const char *data, uint16_t data_len)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            if (data_len < sizeof(%<blockid>_Setting))
            {
                // Store data
                //%<blockid>_Setting [0] = '\0';

                {
                    char *p;
                    int i;
                    uint8_t parse_error;
                    uint32_t zone_id;
                    uint32_t setting_data [44];

                    // Initial buffer
                    for (i=0; i<44; i++) {
	                    setting_data[i] = 0xFFFFFFFF;
                    }
                    // zone_id
                    sscanf (data, "SETTING%u", &zone_id);

                    p = strstr(data,"=");
                    if (p)
                    {
	                    p++;
	                    i = 0;
	                    parse_error = 0;
	                    while (!parse_error && p && *p && (i<44))
	                    {
		                    parse_error = (sscanf(p,"%X",&setting_data[i]) < 1);
		                    p = strstr(p,",");
		                    if (p) p++;
		                    i++;
	                    }

	                    if (!parse_error) {
		                    // Filter invalid version
		                    if (setting_data[1] == 0xFFFFFFFF)
			                    setting_data[1] = 0;
									
		
		                    // ISO Date/time
		                    //get_iso_datetime_str (tmp_buffer);
		
		                    %<blockid>_Setting[0] = '\0';
		                    // gwid=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"gwid=%s", "3G");
		                    // &zoneid=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&zoneid=%u",zone_id);
		                    // &modeid=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&modeid=%d",(setting_data[0]== 0xFFFFFFFF)?-1:(setting_data[0]&0xFF));
		                    // &ver=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&ver=%u",setting_data[1]);
		                    // &datetime=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&datetime=%s","2016-09-16T01:07:18+07:00");
		                    // &mode1enable=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode1enable=");
		                    for (i=0; i<20;i++) {
			                    uint32_t value = setting_data[i*2+2];
			                    if (i>0)
				                    strcpy(&%<blockid>_Setting[strlen(%<blockid>_Setting)],",");
			                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"%u",((value & 0x01000000)==0));
		                    }
		                    // &mode1start=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode1start=");
		                    for (i=0; i<20;i++) {
                    			uint32_t value = setting_data[i*2+2];
			                    if (i>0)
				                    strcpy(&%<blockid>_Setting[strlen(%<blockid>_Setting)],",");
			                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"%u",(value & 0x00FFFFFF));
		                    }
		                    // &mode1runtime=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode1runtime=");
		                    for (i=0; i<20;i++) {
			                    uint32_t value = setting_data[i*2+3];
			                    if (i>0)
				                    strcpy(&%<blockid>_Setting[strlen(%<blockid>_Setting)],",");
			                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"%u",(value & 0x00FFFFFF));
		                    }							
		                    // &mode1day=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode1day=");
		                    for (i=0; i<20;i++) {
			                    uint32_t value = setting_data[i*2+3];
			                    if (i>0)
				                    strcpy(&%<blockid>_Setting[strlen(%<blockid>_Setting)],",");
			                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"%u",(value >> 24));
		                    }
		                    // &mode2timer=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode2timer=");
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"%u",(setting_data[42] & 0x007FFFFF));
		                    // &mode2runtime=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode2runtime=");
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"%u",(setting_data[43] & 0x007FFFFF));
		                    // &mode2repeat=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode2repeat=");
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"%u",((setting_data[42] & 0x00800000)>0));
		                    // &mode3on=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode3on=%u", (setting_data[43]>>24));
		                    // &mode3off=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode3off=%u",(setting_data[42]>>24));
		                    // &mode3input=
		                    sprintf(&%<blockid>_Setting[strlen(%<blockid>_Setting)],"&mode3input=%u",1/*debug*/);

                            process_trigged = 1;

                            // Change status to busy
                            sta = STA_HTTP_BUSY;
	                    }
                        else {
                            // Parse error
                            sta = STA_HTTP_ERROR;
                        }
                    }
                    else {
                        // Input error
                        sta = STA_HTTP_ERROR;
                    }
                }
            }
            else { sta = STA_HTTP_ERROR; }
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        //float _data26[26];
        //uint32_t _data3[3] = {0,0,0};

        sta = aMG_Upload_Data (&%<blockid>_Session, 1/*Setting*/, 0/*Channel*/, %<blockid>_Setting);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;
            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 5) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- upload_sysmsg ---
%if conf == "upload_sysmsg"
static char %<blockid>_SysMsg[256] = {0};
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t %<blockid>_Upload_SystemMessage(uint8_t trig, const uint8_t *data, uint16_t data_len)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            if (data_len < sizeof(%<blockid>_SysMsg))
            {
                // Store data
                memcpy(%<blockid>_SysMsg, data, data_len);
                %<blockid>_SysMsg [data_len] = '\0';
                process_trigged = 1;

                // Change status to busy
                sta = STA_HTTP_BUSY;
            }
            else { sta = STA_HTTP_ERROR; }
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        //float _data26[26];
        //uint32_t _data3[3] = {0,0,0};

        sta = aMG_Upload_Data (&%<blockid>_Session, 2/*SysMsg*/, 0/*Channel*/, %<blockid>_SysMsg);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;

            if (sta == STA_HTTP_SUCCESS) {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 5) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- download_seting ---
%if conf == "download_setting"
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
static uint8_t %<blockid>_channel = 0;
uint8_t %<blockid>_Download_Setting(uint8_t trig, uint8_t channel, uint8_t *output, uint16_t output_len, uint16_t *return_len)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {

            %<blockid>_channel = channel;
            process_trigged = 1;
            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Download_Setting (&%<blockid>_Session, %<blockid>_channel, (char *)output, (int32_t) output_len, return_len);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;

            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 5) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- download_seting_version ---
%if conf == "download_setting_version"
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
static uint32_t %<blockid>_Version_buffer[32];
uint8_t %<blockid>_Download_Setting_Version (uint8_t trig, uint32_t *version)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            process_trigged = 1;
            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Download_Setting_Version (&%<blockid>_Session, %<blockid>_Version_buffer);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;

            if (sta == STA_HTTP_SUCCESS)
            {
                int i;
                for (i=0; i<32; i++) {
                  version[i] = %<blockid>_Version_buffer[i];
                }
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 5) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- getnetworktime ---
%if conf == "getnetworktime"
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t  %<blockid>_Get_NetworkTime (uint8_t trig, uint8_t *datetime_7)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            process_trigged = 1;
            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Get_NetworkTime (&%<blockid>_Session, datetime_7);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;
        }
    }

    return (uint8_t)sta;  
}
%endif

%% --- download_firmware ---
%if conf == "download_firmware"
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t %<blockid>_Download_Firmware (uint8_t trig, uint32_t flash_sta,
      uint32_t signature, uint32_t *flash_cmd, uint32_t *flash_offset,
      uint32_t *flash_data, uint32_t flash_data_count)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            process_trigged = 1;
            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Download_Firmware (&%<blockid>_Session, "%<target_upgrade>", 
        flash_sta, signature, flash_data_count, flash_cmd, flash_offset, flash_data);

        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;

            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 5) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- get ---
%if conf == "get"
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t %<blockid>_HTTP_GET(uint8_t trig, const uint8_t *url, int32_t url_len, 
      uint8_t *output, uint16_t output_len, uint16_t *return_len)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            process_trigged = 1;
            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Http_Get (&%<blockid>_Session, url, url_len, output, output_len, return_len);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;

            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 5) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- post ---
%if conf == "post"
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t %<blockid>_HTTP_POST(uint8_t trig, const uint8_t *action, int32_t action_len, 
      const uint8_t *body, uint16_t body_len)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            process_trigged = 1;
            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Http_Post (&%<blockid>_Session, action, action_len, body, body_len);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;
            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 10) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count >= 3) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- sms ---
%if conf == "sms"
static uint8_t %<blockid>_Session = 0;
static uint8_t %<blockid>_Error_Count = 0;
uint8_t %<blockid>_SMS_Send(uint8_t trig, uint8_t max_count, const uint8_t *number, int32_t number_len, 
      const uint8_t *body, uint16_t body_len, uint8_t *err_code, uint8_t *scc_cnt, uint8_t *err_cnt)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            process_trigged = 1;
            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Sms_Send (&%<blockid>_Session, number, max_count, number_len, body, body_len, err_code, scc_cnt, err_cnt);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;

            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 2) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 1) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- email ---
%if conf == "email"
static uint8_t %<blockid>_Error_Count = 0;
static uint8_t %<blockid>_Session = 0;
uint8_t %<blockid>_EMAIL_Send(uint8_t trig, 
       const uint8_t *server, int32_t server_len, 
       uint32_t port,
       const uint8_t *user, int32_t user_len,
       const uint8_t *pass, int32_t pass_len,
       const uint8_t *sender, int32_t sender_len,
       const uint8_t *to, int32_t to_len,
       const uint8_t *cc, int32_t cc_len,
       const uint8_t *subject, int32_t subject_len,
       const uint8_t *body, int32_t body_len)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            process_trigged = 1;
            // Change status to busy
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Email_Send (&%<blockid>_Session, 
        (char *)server, server_len, port, (char *)user, user_len, (char *)pass, pass_len,
        (char *)sender, sender_len, (char *)to, to_len, (char *)cc, cc_len, (char *)subject, subject_len,
        (char *)body, body_len);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;

            if (sta == STA_HTTP_SUCCESS)
            {
                %<blockid>_Error_Count = 0;
            }
            else { // ERROR or TIMEOUT
                if (%<blockid>_Error_Count < 255)
                    %<blockid>_Error_Count ++;

                if (%<blockid>_Error_Count > 2) {
                   UC15_Module_Pwrcmd.Power_Main_Reset = 0xAABBCCDD;
                   %<blockid>_Error_Count = 0;
                }
                else if (%<blockid>_Error_Count > 1) {
                    UC15_Module_Pwrcmd.Power_Key_Reset = 0xEEFFAABB;
                }
            }
        }
        else
        {
            // TODO:
            // To check processing timeout 3Min

        }
    }

    return (uint8_t)sta;
}
%endif

%% --- systemconf ---
%if conf == "systemconf"
static uint8_t %<blockid>_Session = 0;
uint8_t %<blockid>_System_Conf (uint8_t trig, uint32_t *antid, uint8_t *remoteid, uint16_t remoteid_len)
{
    static uint8_t process_trigged = 0;
    static STA_HTTP_STATUS sta = STA_HTTP_IDLE;

    if (process_trigged == 0) // Not trigged
    {
        // Wait trigger
        if (trig)
        {
            process_trigged = 1;
            sta = STA_HTTP_BUSY;
        }
        else { sta = STA_HTTP_IDLE; }
    }
    else if (process_trigged == 1)
    {
        if (uc15_session_lock (&%<blockid>_Session))
            process_trigged ++;
    }
    else // Trigged, currently busy
    {
        sta = aMG_Get_System_Conf (&%<blockid>_Session, antid, (char *)remoteid, remoteid_len);
        if (sta != STA_HTTP_BUSY)
        {
            process_trigged = 0;
        }
    }

    return (uint8_t)sta;
}
%endif

%% --- getrssi ---
%if conf == "getrssi"
int32_t %<blockid>_get_rssi(void)
{
  return _uc15_get_rssi();
}
%endif

void enable_%<blockid>(void){
  %if conf == "setup"
  // PWR_KEY
  NRF_GPIO->PIN_CNF[UC15_PWRKEY_PIN_NUMBER] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
    | (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos)
    | (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
    | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
    | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
  // RESET
  NRF_GPIO->PIN_CNF[UC15_RESET_PIN_NUMBER] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
    | (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos)
    | (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
    | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
    | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
  // VBAT ENABLE
  NRF_GPIO->PIN_CNF[UC15_VBATENABLE_PIN_NUMBER] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
    | (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos)
    | (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
    | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
    | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);

  UC15_VBAT_ENABLE();

  // Buffer init
  strcpy (UC15_System_Message, "System startup...");
  // Session control

  // Network parameter
  strcpy(UC15_Module_Setting.Apn, "%<apn>");
  strcpy(UC15_Module_Setting.User, "%<user>");
  strcpy(UC15_Module_Setting.Pass, "%<password>");	

  // Module information
  memset(UC15_Module_Info.imei, 0, sizeof(UC15_Module_Info.imei));
  UC15_Module_Info.module_info[0] = '\0';
  UC15_Module_Info.ant_id = 0;

  // Power Reset command
  UC15_Module_Pwrcmd.Power_Key_Reset = 0;
  UC15_Module_Pwrcmd.Power_Main_Reset = 0;
  UC15_Module_Pwrcmd.Requst_Sync_Setting = 0;

  // Reset Data time
  UC15_Module_Info.datetime[0] = 0;
  UC15_Module_Info.datetime[1] = 0;
  UC15_Module_Info.datetime[2] = 0;
  UC15_Module_Info.datetime[3] = 0;
  UC15_Module_Info.datetime[4] = 0;
  UC15_Module_Info.datetime[5] = 0;
  UC15_Module_Info.datetime[6] = 0;

  %endif
}

%closefile tmpBuf
%assign file = LibCreateSourceFile("Source", "Custom","waijung_hwdrvlib")
%<LibAddSourceFileCustomSection(file,"Declarations","cFunctions")>
%<LibSetSourceFileCustomSection(file,"cFunctions",tmpBuf)>
%endfunction

%function Outputs(block, system) Output
%<addParametersToBlock(block)>
/* %<blockid>: '%<block.Name>' */
%% setup
%% upload_data
%if conf == "upload_data"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign len = LibBlockInputSignal(1, "", "", 0)
  %assign data = LibBlockInputSignalAddr(2, "", "", 0)
  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %<status> = %<blockid>_Upload_Data(%<trig>, %<data>, %<len>);
%endif

%% upload_setting
%if conf == "upload_setting"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign len = LibBlockInputSignal(1, "", "", 0)
  %assign data = LibBlockInputSignalAddr(2, "", "", 0)
  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %<status> = %<blockid>_Upload_Setting(%<trig>, (char *)%<data>, %<len>);
%endif

%% upload_setting_version
%if conf == "upload_setting_version"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign version = LibBlockInputSignalAddr(1, "", "", 0)
  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %<status> = %<blockid>_Upload_Setting_Version(%<trig>, %<version>);
%endif

%% upload_sysmsg
%if conf == "upload_sysmsg"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign len = LibBlockInputSignal(1, "", "", 0)
  %assign data = LibBlockInputSignalAddr(2, "", "", 0)
  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %<status> = %<blockid>_Upload_SystemMessage(%<trig>, %<data>, %<len>);
%endif

%% download_setting
%if conf == "download_setting"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign channel = LibBlockInputSignal(1, "", "", 0)

  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %assign len = LibBlockOutputSignalAddr(1, "", "", 0)
  %assign output_len = LibBlockOutputSignalWidth(2)
  %assign output = LibBlockOutputSignalAddr(2, "", "", 0)
  %<status> = %<blockid>_Download_Setting(%<trig>, %<channel>,%<output>, %<output_len>, %<len>);
%endif

%% download_setting_version
%if conf == "download_setting_version"
  %assign trig = LibBlockInputSignal(0, "", "", 0)

  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %assign version = LibBlockOutputSignalAddr(1, "", "", 0)
  %<status> = %<blockid>_Download_Setting_Version(%<trig>, %<version>);
%endif

%% download_firmware
%if conf == "download_firmware"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign flash_sta = LibBlockInputSignal(1, "", "", 0)
  %assign signature = LibBlockInputSignal(2, "", "", 0)

  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %assign flash_cmd = LibBlockOutputSignalAddr(1, "", "", 0)
  %assign flash_offset = LibBlockOutputSignalAddr(2, "", "", 0)
  %assign flash_data = LibBlockOutputSignalAddr(3, "", "", 0)
  %assign flash_data_len = LibBlockOutputSignalWidth(3)

  %<status> = %<blockid>_Download_Firmware (%<trig>, %<flash_sta>,
      %<signature>, %<flash_cmd>, %<flash_offset>,
      %<flash_data>, %<flash_data_len>);
%endif

%% post
%if conf == "post"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign action = LibBlockInputSignalAddr(1, "", "", 0)
  %assign action_len = LibBlockInputSignalWidth(1)
  %assign body = LibBlockInputSignalAddr(2, "", "", 0)
  %assign body_len = LibBlockInputSignalWidth(2)

  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %<status> = %<blockid>_HTTP_POST(%<trig>, %<action>, %<action_len>, %<body>, %<body_len>);
%endif

%% get
%if conf == "get"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign url = LibBlockInputSignalAddr(1, "", "", 0)
  %assign url_len = LibBlockInputSignalWidth(1)

  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %assign len = LibBlockOutputSignalAddr(1, "", "", 0)
  %assign output_len = LibBlockOutputSignalWidth(2)
  %assign output = LibBlockOutputSignalAddr(2, "", "", 0)
  %<status> = %<blockid>_HTTP_GET(%<trig>, %<url>, %<url_len>, %<output>, %<output_len>, %<len>);
%endif

%% sms
%if conf == "sms"
  %assign trig = LibBlockInputSignal(0, "", "", 0)
  %assign max_count = LibBlockInputSignal(1, "", "", 0)
  %assign number = LibBlockInputSignalAddr(2, "", "", 0)
  %assign number_len = LibBlockInputSignalWidth(2)
  %assign body = LibBlockInputSignalAddr(3, "", "", 0)
  %assign body_len = LibBlockInputSignalWidth(3)

  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %assign err_code = LibBlockOutputSignalAddr(1, "", "", 0)
  %assign success_cnt = LibBlockOutputSignalAddr(2, "", "", 0)
  %assign error_cnt = LibBlockOutputSignalAddr(3, "", "", 0)

  %<status> = %<blockid>_SMS_Send(%<trig>, %<max_count>, %<number>, %<number_len>, %<body>, %<body_len>,%<err_code>,%<success_cnt>,%<error_cnt>);
%endif

%% email
%if conf == "email"
  %assign p_trig = LibBlockInputSignal(0, "", "", 0)
  %% Server
  %assign p_server = LibBlockInputSignalAddr(1, "", "", 0)
  %assign p_server_len = LibBlockInputSignalWidth(1)
  %% Port
  %assign p_port = LibBlockInputSignal(2, "", "", 0)
  %% User
  %assign p_user = LibBlockInputSignalAddr(3, "", "", 0)
  %assign p_user_len = LibBlockInputSignalWidth(3)
  %% Password
  %assign p_pass = LibBlockInputSignalAddr(4, "", "", 0)
  %assign p_pass_len = LibBlockInputSignalWidth(4)
  %% Sender
  %assign p_sender = LibBlockInputSignalAddr(5, "", "", 0)
  %assign p_sender_len = LibBlockInputSignalWidth(5)
  %% To
  %assign p_to = LibBlockInputSignalAddr(6, "", "", 0)
  %assign p_to_len = LibBlockInputSignalWidth(6)
  %% Cc
  %assign p_cc = LibBlockInputSignalAddr(7, "", "", 0)
  %assign p_cc_len = LibBlockInputSignalWidth(7)
  %% Subject
  %assign p_subject = LibBlockInputSignalAddr(8, "", "", 0)
  %assign p_subject_len = LibBlockInputSignalWidth(8)
  %% Body
  %assign p_body = LibBlockInputSignalAddr(9, "", "", 0)
  %assign p_body_len = LibBlockInputSignalWidth(9)

  %assign status = LibBlockOutputSignal(0, "", "", 0)

  %<status> = %<blockid>_EMAIL_Send(%<p_trig>, 
       %<p_server>, %<p_server_len>, %<p_port>, 
       %<p_user>, %<p_user_len>, %<p_pass>, %<p_pass_len>,
       %<p_sender>, %<p_sender_len>, %<p_to>, %<p_to_len>,
       %<p_cc>, %<p_cc_len>, %<p_subject>, %<p_subject_len>,
       %<p_body>, %<p_body_len>);
%endif

%% systemconf
%if conf == "systemconf"
  %assign trig = LibBlockInputSignal(0, "", "", 0)

  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %assign antid = LibBlockOutputSignalAddr(1, "", "", 0)
  %assign remoteid = LibBlockOutputSignalAddr(2, "", "", 0)
  %assign remoteidwidth = LibBlockOutputSignalWidth(2)
  %<status> = %<blockid>_System_Conf (%<trig>, %<antid>, %<remoteid>, %<remoteidwidth>);
%endif

%% getnetworktime
%if conf == "getnetworktime"
  %assign trig = LibBlockInputSignal(0, "", "", 0)

  %assign status = LibBlockOutputSignal(0, "", "", 0)
  %assign datetime = LibBlockOutputSignalAddr(1, "", "", 0)
  %<status> = %<blockid>_Get_NetworkTime (%<trig>, %<datetime>);
%endif

%% systemmessage
%if conf == "systemmessage"
  %assign len = LibBlockOutputSignal(0, "", "", 0)
  %assign msg = LibBlockOutputSignalAddr(1, "", "", 0)
  %assign msg_len = LibBlockOutputSignalWidth(1)
  %<len> = UC15_GetSystem_Message (%<msg>, %<msg_len>);
%endif

%% getrssi
%if conf == "getrssi"
  %assign rssi = LibBlockOutputSignal(0, "", "", 0)
  %<rssi> = %<blockid>_get_rssi();
%endif

%endfunction

%function Enable(block, system) Output
%<addParametersToBlock(block)>
enable_%<blockid>();
%endfunction

%function Disable(block, system) Output
%<addParametersToBlock(block)>
%%disable_%<blockid>();
%endfunction

%function Terminate(block, system) Output
%<addParametersToBlock(block)>
%%/* terminate_%<blockid>(); */
%endfunction

